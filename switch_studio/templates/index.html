<!DOCTYPE html>
<html>
<head>
    <title>Inovelli Switch Studio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #1a1a1a; color: #eee; margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        /* Header */
        .header { background: #2b2b2b; padding: 10px 15px; border-bottom: 2px solid #00bcd4; display: flex; justify-content: space-between; align-items: center; z-index: 10; gap: 15px;}
        .header h2 { color: #00bcd4; margin: 0; white-space: nowrap; }
        
        /* Header Controls Group */
        .header-controls { display: flex; align-items: center; gap: 10px; flex-grow: 1; justify-content: flex-start; }
        select#deviceSelect { background: #333; color: white; border: 1px solid #00bcd4; padding: 6px 12px; font-size: 14px; border-radius: 4px; cursor: pointer; max-width: 300px; width: 100%; }
        
        .status-bar { font-size: 0.9em; color: #888; text-align: center; background: #222; padding: 5px; display: flex; justify-content: center; gap: 10px; align-items: center; }
        #packetInfo { color: #00bcd4; font-weight: bold; }
        #timestamp { color: #ff9800; font-family: monospace; }
        #packetAge { color: #666; font-size: 0.85em; font-family: monospace; min-width: 60px; text-align: left; }

        /* Tabs + Dirty State */
        .tab-bar { display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #181818; border-top: 1px solid #333; border-bottom: 1px solid #333; overflow-x: auto; }
        .tab-btn { background: #2b2b2b; color: #bfbfbf; border: 1px solid #444; padding: 6px 12px; border-radius: 999px; cursor: pointer; font-size: 0.85em; }
        .tab-btn:hover { border-color: #00bcd4; color: #e5fafd; }
        .tab-btn.active { background: #00bcd4; color: #111; border-color: #00bcd4; font-weight: 600; }

        .dirty-bar { display: flex; justify-content: space-between; align-items: center; gap: 10px; background: #1f1f1f; border-bottom: 1px solid #333; padding: 8px 12px; color: #888; }
        .dirty-bar.dirty-active { color: #ffcc80; border-bottom-color: #ff9800; }
        .dirty-actions { display: flex; gap: 8px; }
        .dirty-btn { background: #2b2b2b; color: #ddd; border: 1px solid #555; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.82em; }
        .dirty-btn:disabled { opacity: 0.45; cursor: not-allowed; }
        .dirty-btn:not(:disabled):hover { border-color: #00bcd4; color: #fff; }
        .dirty-btn.apply-btn { border-color: #4caf50; }
        .dirty-btn.apply-btn:not(:disabled):hover { background: #4caf50; color: #111; }

        /* Toasts */
        #toastContainer { position: fixed; right: 18px; bottom: 18px; z-index: 2500; display: flex; flex-direction: column; gap: 8px; pointer-events: none; max-width: min(420px, 85vw); }
        .studio-toast { background: rgba(35, 35, 35, 0.98); border: 1px solid #555; color: #f3f3f3; border-radius: 6px; padding: 10px 12px; box-shadow: 0 8px 20px rgba(0,0,0,0.35); font-size: 0.86em; transition: opacity 0.2s ease, transform 0.2s ease; }
        .studio-toast.fade-out { opacity: 0; transform: translateY(6px); }
        .studio-toast-saved { border-color: #4caf50; }
        .studio-toast-syncing { border-color: #00bcd4; }
        .studio-toast-error { border-color: #ff5252; }

        /* Main Layout Grid */
        .app-container { display: grid; grid-template-columns: minmax(0, 1fr) 360px; flex-grow: 1; overflow: hidden; transition: 0.3s; }
        .main-content { display: flex; flex-direction: column; padding: 12px 14px 16px; overflow-y: auto; position: relative; gap: 14px; }
        .sidebar { background: #222; border-left: 1px solid #444; padding: 14px; overflow-y: auto; display: flex; flex-direction: column; gap: 14px; transition: opacity 0.3s; }
        .app-container.focus-config { display: block; overflow-y: auto; }
        .app-container.focus-config .main-content { padding: 10px 14px 2px; min-height: auto; }
        .app-container.focus-config .sidebar { border-left: none; background: transparent; max-width: 1200px; margin: 0 auto; padding: 8px 14px 24px; }
        .app-container.focus-config .sidebar details,
        .app-container.focus-config .sidebar .config-group {
            background: #262c31;
            border-color: #3a4650;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        /* Chart & Table */
        #chart { width: 100%; flex-grow: 1; min-height: 440px; border-radius: 10px; border: 1px solid rgba(0, 188, 212, 0.22); box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03), 0 10px 25px rgba(0, 0, 0, 0.3); }
        
        .table-container { background: #23282d; border: 1px solid #35404a; border-radius: 8px; overflow-x: auto; box-shadow: 0 10px 24px rgba(0,0,0,0.25); }
        table { width: 100%; border-collapse: collapse; text-align: center; min-width: 500px; }
        th { background: #00bcd4; color: #1a1a1a; padding: 8px; font-weight: bold; }
        td { padding: 8px; border-bottom: 1px solid #444; }
        .no-data { padding: 15px; font-style: italic; color: #888; }

        /* Collapsible Sections */
        details { background: #2b2b2b; border-radius: 6px; border: 1px solid #333; }
        details > summary { font-weight: bold; color: #00bcd4; padding: 12px; cursor: pointer; list-style: none; user-select: none; display: flex; justify-content: space-between; align-items: center; }
        details > summary::-webkit-details-marker { display: none; }
        details > summary::after { content: 'v'; font-size: 0.8em; color: #666; transition: 0.2s; }
        details[open] > summary::after { transform: rotate(180deg); color: #00bcd4; }
        details[open] > summary { border-bottom: 1px solid #444; }
        .config-content { padding: 12px; }

        /* Radar Container needs flex to handle Plotly resizing */
        #chartContainer[open] .config-content {
            display: flex;
            flex-direction: column;
            height: 58vh;
            padding: 0;
            overflow: hidden;
        }

        /* Config Groups */
        .config-group { background: #2b2b2b; padding: 12px; border-radius: 6px; border: 1px solid #333; }
        .config-title { font-weight: bold; color: #00bcd4; margin-bottom: 10px; border-bottom: 1px solid #444; padding-bottom: 5px; font-size: 0.95em; }

        /* Inputs */
        .input-row { display: grid; grid-template-columns: minmax(0, 1fr) auto; gap: 10px; align-items: center; margin-bottom: 8px; font-size: 0.9em; }
        .input-row label { color: #ccc; min-width: 0; line-height: 1.2; overflow-wrap: anywhere; }
        input[type="number"] { width: 130px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; padding: 3px 5px; text-align: right; }
        .control-select { width: 142px; margin-top: 5px; background: #333; border: 1px solid #555; color: white; padding: 3px; }
        .full-width-select { width: 100%; max-width: 100%; box-sizing: border-box; margin-top: 5px; background: #333; border: 1px solid #555; color: white; padding: 5px; }
        
        /* Settings Checkboxes */
        .input-row input[type="checkbox"] { width: auto; cursor: pointer; }

        /* Grid for Raw Zone Data */
        .zone-data-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px; }
        .zone-input-group { display: flex; flex-direction: column; gap: 2px; }
        .zone-input-group label { font-size: 0.75em; color: #888; }
        .zone-input-group input { width: 100%; box-sizing: border-box; font-family: monospace; color: #00bcd4; font-weight: bold;}

        /* Live Sensor Badges */
        .sensor-row { display: flex; justify-content: space-between; background: #1f2328; border: 1px solid #323b44; padding: 8px 10px; border-radius: 6px; margin-bottom: 6px; }
        .sensor-val { font-weight: bold; color: #fff; }
        .badge-detected { color: #4caf50; font-weight: bold; }
        .badge-clear { color: #888; font-style: italic; }

        /* Small badges for Zone Status */
        .zone-badge { font-size: 0.85em; padding: 2px 6px; border-radius: 3px; background: #333; color: #888; }
        .zone-active { background: #2e7d32; color: white; }

        /* Buttons */
        .cmd-btn { background: #444; color: white; border: 1px solid #00bcd4; padding: 6px 10px; border-radius: 4px; cursor: pointer; transition: 0.2s; font-size: 0.85em; white-space: nowrap;}
        .cmd-btn:hover { background: #00bcd4; color: #1a1a1a; }
        .btn-danger { border-color: #ff5252; }
        .btn-danger:hover { background: #ff5252; color: white; }
        .btn-full { width: 100%; margin-bottom: 5px; }

        .command-log { background: #1a1a1a; border: 1px solid #333; border-radius: 4px; padding: 8px; max-height: 150px; overflow-y: auto; font-size: 0.82em; font-family: Consolas, 'Courier New', monospace; }
        .command-log-empty { color: #777; font-style: italic; }
        .command-log-entry { margin-bottom: 5px; }
        .command-log-entry:last-child { margin-bottom: 0; }
        .command-log-entry.log-syncing { color: #00bcd4; }
        .command-log-entry.log-saved { color: #4caf50; }
        .command-log-entry.log-error { color: #ff5252; }
        .command-log-entry.log-info { color: #bbb; }

        .schema-section-title { font-size: 0.85em; color: #9ec8cf; margin: 8px 0 6px 0; border-bottom: 1px dashed #3a3a3a; padding-bottom: 4px; }
        .schema-composite-block { border: 1px solid #3a3a3a; border-radius: 4px; padding: 8px; margin-bottom: 8px; background: #1f1f1f; }
        .schema-composite-title { color: #00bcd4; font-weight: 600; margin-bottom: 6px; font-size: 0.86em; }
        .schema-composite-note { color: #777; font-size: 0.78em; margin-top: 4px; }
        .led-color-select { width: 176px; }
        .slider-control { display: flex; align-items: center; justify-content: flex-end; gap: 8px; min-width: 190px; }
        .slider-control input[type="range"] { width: 128px; accent-color: #00bcd4; }
        .slider-value { min-width: 42px; text-align: right; color: #9ec8cf; font-family: Consolas, 'Courier New', monospace; font-size: 0.8em; }

        .target-report-card { background: linear-gradient(135deg, rgba(0, 188, 212, 0.14), rgba(24, 24, 24, 0.92)); border: 1px solid rgba(0, 188, 212, 0.45); border-radius: 8px; padding: 10px 12px; }
        .target-report-row { display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap; }
        .target-report-meta { display: flex; align-items: center; gap: 8px; color: #9ec8cf; font-size: 0.86em; }
        .target-report-state { font-weight: 700; padding: 2px 8px; border-radius: 999px; border: 1px solid #555; color: #bbb; }
        .target-report-state-on { color: #111; border-color: #4caf50; background: #4caf50; }
        .target-report-state-off { color: #ddd; border-color: #666; background: #3b3b3b; }
        .target-report-control { display: flex; align-items: center; gap: 8px; color: #ddd; font-size: 0.88em; }
        .target-report-control input[type="checkbox"] { transform: scale(1.08); cursor: pointer; }

        #zoneStatus { display: none; position: fixed; top: 20px; right: 20px; background: #333; color: white; padding: 15px 20px; border-radius: 6px; z-index: 1000; }

        /* Non-mmWave Overlay Warning */
        #nonMmwaveWarning {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 82, 82, 0.9);
            color: white;
            padding: 20px 30px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 20;
        }

        /* Responsive Design: Mobile Layout Adjustments */
        @media (max-width: 900px) {
            .app-container { display: block; overflow-y: auto; -webkit-overflow-scrolling: touch; }
            .main-content { overflow: visible; height: auto; flex: none; padding-bottom: 20px; }
            .sidebar { border-left: none; border-top: 1px solid #444; height: auto; overflow: visible; flex: none; padding-bottom: 40px; }
            #chartContainer[open] .config-content { height: 350px; }
            #chart { min-height: 0; height: 100%; }
            .table-container { width: 100%; margin-bottom: 15px; }
            table { min-width: unset; font-size: 0.8rem; }
            th, td { padding: 6px 3px; }
            .header { padding: 5px 10px; }
            .header h2 { display: none; } 
            .header-controls { width: 100%; justify-content: space-between; }
            select#deviceSelect { flex-grow: 1; max-width: unset; margin-right: 5px; }
            .tab-bar { gap: 6px; padding: 8px 10px; }
            .tab-btn { padding: 5px 10px; font-size: 0.8em; }
            .dirty-bar { padding: 8px 10px; flex-wrap: wrap; }
            .dirty-actions { width: 100%; justify-content: flex-end; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h2>Inovelli Switch Studio</h2>
        <div class="header-controls">
            <select id="deviceSelect"><option value="" disabled selected>Loading devices...</option></select>
            <button class="cmd-btn" id="btnForceSync" onclick="handleForceSyncClick()">Force Sync</button>
        </div>
    </div>

    <div class="status-bar">
        <span id="statusDiv">Waiting for connection...</span> | 
        <span id="packetInfo">Awaiting data...</span> |
        <span>Last Packet: <span id="timestamp">--:--:--</span></span>
        <span id="packetAge"></span>
    </div>

    <div class="tab-bar" id="tabBar" role="tablist" aria-label="Inovelli Switch Studio tabs">
        <button class="tab-btn" type="button" data-tab-target="zones" role="tab" aria-selected="true">Presence & Zones</button>
        <button class="tab-btn" type="button" data-tab-target="load" role="tab" aria-selected="false">Load & Dimming</button>
        <button class="tab-btn" type="button" data-tab-target="led" role="tab" aria-selected="false">LED & Notifications</button>
        <button class="tab-btn" type="button" data-tab-target="buttons" role="tab" aria-selected="false">Buttons & Scenes</button>
        <button class="tab-btn" type="button" data-tab-target="power" role="tab" aria-selected="false">Power & Device</button>
        <button class="tab-btn" type="button" data-tab-target="advanced" role="tab" aria-selected="false">Advanced</button>
    </div>
    <div class="dirty-bar" id="dirtyBar">
        <span id="dirtyText">No pending changes</span>
        <div class="dirty-actions">
            <button class="dirty-btn" id="btnDiscardChanges" type="button" disabled>Discard</button>
            <button class="dirty-btn apply-btn" id="btnApplyChanges" type="button" disabled>Apply</button>
        </div>
    </div>

    <div id="zoneStatus"></div>
    <div id="toastContainer"></div>

    <div class="app-container focus-zones" id="appContainer">
        <div class="main-content">
            <div id="nonMmwaveWarning" data-tab-panels="zones,load,led,buttons,power,advanced">WARNING: Standard Switch Detected<br><span style="font-size: 0.8em; font-weight: normal;">This device does not have mmWave hardware.</span></div>

            <div class="target-report-card" data-tab-panels="zones">
                <div class="target-report-row">
                    <div>
                        <div class="config-title" style="margin-bottom: 6px;">Target Reporting</div>
                        <div class="target-report-meta">
                            <span id="targetReportState" class="target-report-state target-report-state-off">OFF</span>
                            <span id="targetReportValueLabel">mmWaveTargetInfoReport</span>
                        </div>
                    </div>
                    <label class="target-report-control">
                        <input type="checkbox" id="targetReportToggle">
                        Stream live target packets
                    </label>
                    <label class="target-report-control">
                        <input type="checkbox" id="targetReportAutoOffToggle">
                        Auto-off on disconnect
                    </label>
                </div>
            </div>
            
            <details open id="chartContainer" data-tab-panels="zones">
                <summary>Live Radar Map</summary>
                <div class="config-content">
                    <div id="chart"></div>
                </div>
            </details>

            <div class="table-container" data-tab-panels="zones">
                <table>
                    <thead>
                        <tr>
                            <th>Target ID</th>
                            <th>X (Width)</th>
                            <th>Y (Depth)</th>
                            <th>Z (Height)</th>
                            <th>Action (Doppler)</th>
                        </tr>
                    </thead>
                    <tbody id="dataTableBody">
                        <tr><td colspan="5" class="no-data">No targets detected</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="sidebar" id="configSidebar">
            
            <div class="config-group" style="background: #1e1e1e; border-color: #00bcd4;" data-tab-panels="zones">
                <div class="config-title" style="color: #00bcd4;">Live Sensors</div>
                <div class="sensor-row">
                    <span style="color: #ccc;">Area 1 (Primary):</span>
                    <span id="occupancyVal" class="sensor-val badge-clear">Waiting...</span>
                </div>
                <div class="sensor-row">
                    <span style="color: #ccc;">Illuminance:</span>
                    <span id="illuminanceVal" class="sensor-val">-- lx</span>
                </div>
            </div>

            <details open class="mobile-collapsed" id="zoneStatusSection" data-tab-panels="zones">
                <summary>Zone Status</summary>
                <div class="config-content">
                    <div class="sensor-row">
                        <span style="color: #ccc;">Area 1:</span>
                        <span id="area1Val" class="zone-badge">CLEAR</span>
                    </div>
                    <div class="sensor-row">
                        <span style="color: #ccc;">Area 2:</span>
                        <span id="area2Val" class="zone-badge">CLEAR</span>
                    </div>
                    <div class="sensor-row">
                        <span style="color: #ccc;">Area 3:</span>
                        <span id="area3Val" class="zone-badge">CLEAR</span>
                    </div>
                    <div class="sensor-row">
                        <span style="color: #ccc;">Area 4:</span>
                        <span id="area4Val" class="zone-badge">CLEAR</span>
                    </div>
                </div>
            </details>

            <details open class="mobile-collapsed" data-tab-panels="zones">
                <summary>Zone Editor</summary>
                <div class="config-content">
                    <div style="margin-bottom: 10px; font-size: 0.9em; color: #ccc;">Select a zone to view, draw, or edit.</div>
                    
                    <div class="input-row">
                        <label>Target Zone:</label>
                        <select class="control-select" id="zoneEditorSelect">
                            <option value="mmwave_detection_areas:area1">Detection Area 1 (Primary - Blue)</option>
                            <option value="mmwave_detection_areas:area2">Detection Area 2 (Green)</option>
                            <option value="mmwave_detection_areas:area3">Detection Area 3 (Green)</option>
                            <option value="mmwave_detection_areas:area4">Detection Area 4 (Green)</option>
                            <option value="" disabled>--- Interference Areas ---</option>
                            <option value="mmwave_interference_areas:area1">Interference Area 1 (Red)</option>
                            <option value="mmwave_interference_areas:area2">Interference Area 2 (Red)</option>
                            <option value="mmwave_interference_areas:area3">Interference Area 3 (Red)</option>
                            <option value="mmwave_interference_areas:area4">Interference Area 4 (Red)</option>
                            <option value="" disabled>--- Stay Areas ---</option>
                            <option value="mmwave_stay_areas:area1">Stay Area 1 (Orange)</option>
                            <option value="mmwave_stay_areas:area2">Stay Area 2 (Orange)</option>
                            <option value="mmwave_stay_areas:area3">Stay Area 3 (Orange)</option>
                            <option value="mmwave_stay_areas:area4">Stay Area 4 (Orange)</option>
                        </select>
                    </div>

                    <div id="zoneEditorRawData" style="display: none; border: 1px solid #444; padding: 10px; border-radius: 4px; background: #222; margin-bottom: 10px;">
                        <div style="font-size: 0.85em; font-weight: bold; margin-bottom: 5px; color: #00bcd4;">Raw Zone Data (cm)</div>
                        <div class="zone-data-grid">
                            <div class="zone-input-group"><label>X Min (Width)</label><input type="number" id="editXMin" onchange="manualZoneUpdate()"></div>
                            <div class="zone-input-group"><label>X Max (Width)</label><input type="number" id="editXMax" onchange="manualZoneUpdate()"></div>
                            <div class="zone-input-group"><label>Y Min (Depth)</label><input type="number" id="editYMin" onchange="manualZoneUpdate()"></div>
                            <div class="zone-input-group"><label>Y Max (Depth)</label><input type="number" id="editYMax" onchange="manualZoneUpdate()"></div>
                            <div class="zone-input-group"><label>Z Min (Height)</label><input type="number" id="editZMin" onchange="manualZoneUpdate()"></div>
                            <div class="zone-input-group"><label>Z Max (Height)</label><input type="number" id="editZMax" onchange="manualZoneUpdate()"></div>
                        </div>
                        <div style="display:flex; gap: 5px;">
                            <button class="cmd-btn btn-danger" style="flex:1;" onclick="cancelZoneEdit()">Stop Editing</button>
                            <button class="cmd-btn" style="background: #00bcd4; color: #1a1a1a; flex:1;" onclick="applyZoneEdit()">Apply Changes</button>
                        </div>
                    </div>

                    <button id="btnStartEdit" class="cmd-btn btn-full" onclick="startZoneEdit()" style="margin-top:5px; background: #00bcd4; color: #1a1a1a;">Draw / Edit Selected Zone</button>
                    <button class="cmd-btn btn-full btn-danger" onclick="deleteZone()" style="margin-top:5px;">Delete Selected Zone</button>
                </div>
            </details>

            <details open class="mobile-collapsed" data-tab-panels="zones">
                <summary>Presence & Motion Settings</summary>
                <div class="config-content">
                    <div style="font-size: 0.84em; color: #93b4bc; margin-bottom: 10px;">
                        Core motion behavior settings for occupancy timing, sensitivity, and load control.
                    </div>
                    <div id="schemaPresenceFields">
                        <div style="font-size: 0.9em; color: #888;">Loading schema...</div>
                    </div>
                </div>
            </details>

            <details open class="mobile-collapsed" data-tab-panels="zones">
                <summary>Studio View Settings</summary>
                <div class="config-content">
                    
                    <div style="margin-top:10px; padding-top:5px;">
                        <div style="font-size:0.9em; font-weight:bold; color:#00bcd4; margin-bottom:5px;">Map Visibility</div>
                        <div class="input-row">
                            <label for="vizToggleGrid">Show Radar Grid:</label>
                            <input type="checkbox" id="vizToggleGrid" checked>
                        </div>
                        <div class="input-row">
                            <label for="vizToggleLabels">Show Labels:</label>
                            <input type="checkbox" id="vizToggleLabels" checked>
                        </div>
                        <div class="input-row">
                            <label for="vizToggleZValues">Show Zone Heights:</label>
                            <input type="checkbox" id="vizToggleZValues">
                        </div>
                        <div class="input-row">
                            <label style="color:#00bcd4" for="vizToggleDetection">Show Detection Zones:</label>
                            <input type="checkbox" id="vizToggleDetection" checked>
                        </div>
                        <!-- Individual Detection Toggles -->
                        <div id="detectionSubOptions" style="margin-left: 20px; display: block; border-left: 1px solid #444; padding-left: 10px;">
                            <div class="input-row" style="margin-bottom: 2px;">
                                <label style="font-size: 0.85em;">Area 1 (Primary)</label>
                                <input type="checkbox" id="vizToggleDetection1" checked>
                            </div>
                            <div class="input-row" style="margin-bottom: 2px;">
                                <label style="font-size: 0.85em;">Area 2</label>
                                <input type="checkbox" id="vizToggleDetection2" checked>
                            </div>
                            <div class="input-row" style="margin-bottom: 2px;">
                                <label style="font-size: 0.85em;">Area 3</label>
                                <input type="checkbox" id="vizToggleDetection3" checked>
                            </div>
                            <div class="input-row">
                                <label style="font-size: 0.85em;">Area 4</label>
                                <input type="checkbox" id="vizToggleDetection4" checked>
                            </div>
                        </div>

                        <div class="input-row" style="margin-top: 5px;">
                            <label style="color:#ff9800" for="vizToggleStay">Show Stay Zones:</label>
                            <input type="checkbox" id="vizToggleStay" checked>
                        </div>
                        <div class="input-row">
                            <label style="color:#ff5252" for="vizToggleInterference">Show Interference Zones:</label>
                            <input type="checkbox" id="vizToggleInterference" checked>
                        </div>
                    </div>
                    
                    <div class="config-title" style="margin-top: 15px; border-top: 1px solid #444; padding-top: 5px;">Radar Map Size (cm)</div>
                    <div class="zone-data-grid">
                        <div class="zone-input-group"><label>X Min</label><input type="number" id="vizXMin" value="-650"></div>
                        <div class="zone-input-group"><label>X Max</label><input type="number" id="vizXMax" value="650"></div>
                        <div class="zone-input-group"><label>Y Min</label><input type="number" id="vizYMin" value="-50"></div>
                        <div class="zone-input-group"><label>Y Max</label><input type="number" id="vizYMax" value="650"></div>
                    </div>
                    <button class="cmd-btn btn-full" onclick="updateRadarScale()" style="margin-top:5px; background: #00bcd4; color: #1a1a1a;">Update Scale</button>
                </div>
            </details>

            <details open class="mobile-collapsed" data-tab-panels="load">
                <summary>Load & Dimming (Schema)</summary>
                <div class="config-content">
                    <div id="schemaLoadFields">
                        <div style="font-size: 0.9em; color: #888;">Loading schema...</div>
                    </div>
                </div>
            </details>

            <details open class="mobile-collapsed" data-tab-panels="led">
                <summary>LED & Notifications (Schema)</summary>
                <div class="config-content">
                    <div id="schemaLedFields">
                        <div style="font-size: 0.9em; color: #888;">Loading schema...</div>
                    </div>
                </div>
            </details>

            <details open class="mobile-collapsed" data-tab-panels="buttons">
                <summary>Buttons & Scenes (Schema)</summary>
                <div class="config-content">
                    <div id="schemaButtonFields">
                        <div style="font-size: 0.9em; color: #888;">Loading schema...</div>
                    </div>
                </div>
            </details>

            <details open class="mobile-collapsed" data-tab-panels="power">
                <summary>Power & Device (Schema)</summary>
                <div class="config-content">
                    <div id="schemaPowerFields">
                        <div style="font-size: 0.9em; color: #888;">Loading schema...</div>
                    </div>
                </div>
            </details>

            <details open class="mobile-collapsed" data-tab-panels="advanced">
                <summary>Advanced Settings</summary>
                <div class="config-content">
                    <div style="font-size: 0.84em; color: #93b4bc; margin-bottom: 10px;">
                        Set-and-forget settings. Most users only need to change these during initial setup.
                    </div>
                    <div id="schemaAdvancedFields">
                        <div style="font-size: 0.9em; color: #888;">Loading advanced settings...</div>
                    </div>
                </div>
            </details>

            <details open class="mobile-collapsed" data-tab-panels="advanced">
                <summary>Fan Parameters (May Not Apply)</summary>
                <div class="config-content">
                    <div style="font-size: 0.84em; color: #ffcc80; margin-bottom: 10px;">
                        These values are shared firmware fields and may not function on VZM32-SN.
                    </div>
                    <div id="schemaFanFields">
                        <div style="font-size: 0.9em; color: #888;">Loading fan-related fields...</div>
                    </div>
                </div>
            </details>

            <details open class="mobile-collapsed" data-tab-panels="zones">
                <summary>Maintenance Tools</summary>
                <div class="config-content">
                    <button class="cmd-btn btn-full" onclick="sendCommand(1)">Auto-Config Interference</button>
                    <button class="cmd-btn btn-full btn-danger" onclick="sendCommand(3)">Clear Interference</button>
                    <div style="height: 10px;"></div>
                    <button class="cmd-btn btn-full" onclick="sendCommand(4)">Reset Detection Zones</button>
                    <button class="cmd-btn btn-full" onclick="sendCommand(5)">Clear Stay Zones</button>
                    <div class="config-title" style="margin-top: 12px;">Command Feedback</div>
                    <div id="commandLog" class="command-log">
                        <div class="command-log-empty">No command activity yet.</div>
                    </div>
                </div>
            </details>
        </div>
    </div>

    <script src="{{ ingress_path }}/static/js/app_tabs.js"></script>
    <script src="{{ ingress_path }}/static/js/app_state.js"></script>
    <script src="{{ ingress_path }}/static/js/app_zones.js"></script>
    <script>
        const INGRESS_PATH = "{{ ingress_path }}";
        const SWITCH_STUDIO_UI_ENABLED = {{ 'true' if switch_studio_ui else 'false' }};
        const socket = io({ path: INGRESS_PATH + '/socket.io' });

        const statusDiv = document.getElementById('statusDiv');
        const packetInfo = document.getElementById('packetInfo');
        const timestampSpan = document.getElementById('timestamp');
        const packetAgeSpan = document.getElementById('packetAge');
        const deviceSelect = document.getElementById('deviceSelect');
        const dataTableBody = document.getElementById('dataTableBody');
        const tabBar = document.getElementById('tabBar');
        const appContainer = document.getElementById('appContainer');

        // UI Elements
        const nonMmwaveWarning = document.getElementById('nonMmwaveWarning');
        const configSidebar = document.getElementById('configSidebar');
        const btnForceSync = document.getElementById('btnForceSync');
        const occupancyVal = document.getElementById('occupancyVal');
        const illuminanceVal = document.getElementById('illuminanceVal');
        const dirtyBar = document.getElementById('dirtyBar');
        const dirtyText = document.getElementById('dirtyText');
        const btnApplyChanges = document.getElementById('btnApplyChanges');
        const btnDiscardChanges = document.getElementById('btnDiscardChanges');
        const toastContainer = document.getElementById('toastContainer');
        const commandLog = document.getElementById('commandLog');
        const targetReportToggle = document.getElementById('targetReportToggle');
        const targetReportAutoOffToggle = document.getElementById('targetReportAutoOffToggle');
        const targetReportState = document.getElementById('targetReportState');
        const targetReportValueLabel = document.getElementById('targetReportValueLabel');
        const TARGET_REPORT_AUTO_OFF_STORAGE_KEY = 'switchStudio.targetReportAutoOff';

        // Visualizer Scale Inputs
        const vizXMin = document.getElementById('vizXMin');
        const vizXMax = document.getElementById('vizXMax');
        const vizYMin = document.getElementById('vizYMin');
        const vizYMax = document.getElementById('vizYMax');

        let targetHistory = {}; 
        const HISTORY_LENGTH = 15; 
        
        // Interaction Lock for Jitter Prevention
        let isInteracting = false;
        
        const chartElement = document.getElementById('chart');
        
        // Listeners to detect dragging/interacting
        chartElement.addEventListener('mousedown', () => { isInteracting = true; });
        chartElement.addEventListener('mouseup', () => { isInteracting = false; });
        chartElement.addEventListener('mouseleave', () => { isInteracting = false; });
        chartElement.addEventListener('touchstart', () => { isInteracting = true; }, {passive: true});
        chartElement.addEventListener('touchend', () => { isInteracting = false; });
        
        // Zone Management State
        let deviceZones = {
            // Unify: Area1 is now the Primary zone
            mmwave_detection_areas: { area1: null, area2: null, area3: null, area4: null },
            mmwave_interference_areas: { area1: null, area2: null, area3: null, area4: null },
            mmwave_stay_areas: { area1: null, area2: null, area3: null, area4: null }
        };
        let occupancyState = { global: null, area1: null, area2: null, area3: null, area4: null };

        // Zone Editing State
        let isEditingZone = false;
        let editingTarget = null;
        let draftZoneConfig = null;
        
        const zoneEditorSelect = document.getElementById('zoneEditorSelect');
        const zoneEditorRawData = document.getElementById('zoneEditorRawData');
        const btnStartEdit = document.getElementById('btnStartEdit');

        // Inputs for Raw Data
        const editXMin = document.getElementById('editXMin');
        const editXMax = document.getElementById('editXMax');
        const editYMin = document.getElementById('editYMin');
        const editYMax = document.getElementById('editYMax');
        const editZMin = document.getElementById('editZMin');
        const editZMax = document.getElementById('editZMax');
        const schemaPresenceFields = document.getElementById('schemaPresenceFields');
        const schemaLoadFields = document.getElementById('schemaLoadFields');
        const schemaLedFields = document.getElementById('schemaLedFields');
        const schemaButtonFields = document.getElementById('schemaButtonFields');
        const schemaPowerFields = document.getElementById('schemaPowerFields');
        const schemaAdvancedFields = document.getElementById('schemaAdvancedFields');
        const schemaFanFields = document.getElementById('schemaFanFields');

        let schemaModel = null;
        let schemaFieldMap = {};
        let schemaCompositeMap = {};
        let zoneModule = null;

        function parsePanelTargets(raw) {
            if (!raw) return [];
            return raw
                .split(',')
                .map(item => item.trim())
                .filter(Boolean);
        }

        function parseOccupancyValue(value) {
            if (value === true || value === 'ON' || value === 1 || value === '1') return true;
            if (value === false || value === 'OFF' || value === 0 || value === '0') return false;
            if (typeof value === 'string') {
                const lowered = value.trim().toLowerCase();
                if (lowered === 'true' || lowered === 'detected') return true;
                if (lowered === 'false' || lowered === 'clear') return false;
            }
            return null;
        }

        function hasActiveOccupancy() {
            const states = Object.values(occupancyState).filter(v => v === true || v === false);
            if (states.length === 0) return true;
            return states.some(v => v === true);
        }

        function clearTargetsForOccupancyGate() {
            if (zoneModule && typeof zoneModule.clearTargetVisualization === 'function') {
                zoneModule.clearTargetVisualization('Standby: all occupancy areas clear');
                return;
            }
            targetHistory = {};
            const chartDiv = document.getElementById('chart');
            if (chartDiv && chartDiv.data && window.Plotly) {
                Plotly.restyle('chart', { x: [[]], y: [[]], text: [[]] }, [0]);
                Plotly.restyle('chart', { x: [[]], y: [[]] }, [1]);
            }
            dataTableBody.innerHTML = '<tr><td colspan="5" class="no-data">Standby: all occupancy areas clear.</td></tr>';
        }

        function applyLayoutMode(activeTab) {
            if (!appContainer) return;
            const tab = String(activeTab || '').toLowerCase();
            const zoneFocused = tab === 'zones';
            appContainer.classList.toggle('focus-zones', zoneFocused);
            appContainer.classList.toggle('focus-config', !zoneFocused);
        }

        function applyLegacyLayout() {
            if (tabBar) {
                tabBar.style.display = 'none';
            }

            try {
                localStorage.removeItem('switchStudio.activeTab');
            } catch (err) {
                // Ignore storage failures.
            }

            const allowedPanels = new Set(['zones', 'advanced']);
            const panels = Array.from(document.querySelectorAll('[data-tab-panels]'));
            panels.forEach(panel => {
                const targets = parsePanelTargets(panel.getAttribute('data-tab-panels'));
                const shouldShow = targets.length === 0 || targets.some(target => allowedPanels.has(target));
                panel.style.display = shouldShow ? '' : 'none';
            });
        }

        if (SWITCH_STUDIO_UI_ENABLED && window.SwitchStudioTabs && typeof window.SwitchStudioTabs.init === 'function') {
            window.SwitchStudioTabs.init({
                defaultTab: 'zones',
                onTabChange: (activeTab) => {
                    applyLayoutMode(activeTab);
                    if (String(activeTab || '').toLowerCase() === 'zones') {
                        setTimeout(() => {
                            const chartDiv = document.getElementById('chart');
                            if (chartDiv && chartDiv.data) {
                                Plotly.Plots.resize(chartDiv);
                            }
                        }, 40);
                    }
                }
            });
        } else {
            applyLegacyLayout();
            applyLayoutMode('zones');
        }

        if (window.SwitchStudioState && typeof window.SwitchStudioState.init === 'function') {
            window.SwitchStudioState.init({
                socket: socket,
                packetInfoEl: packetInfo,
                dirtyBarEl: dirtyBar,
                dirtyTextEl: dirtyText,
                applyBtnEl: btnApplyChanges,
                discardBtnEl: btnDiscardChanges,
                toastContainerEl: toastContainer
            });
        }

        function getStoredTargetReportingAutoOff() {
            try {
                return localStorage.getItem(TARGET_REPORT_AUTO_OFF_STORAGE_KEY) === '1';
            } catch (err) {
                return false;
            }
        }

        function persistTargetReportingAutoOff(enabled) {
            try {
                localStorage.setItem(TARGET_REPORT_AUTO_OFF_STORAGE_KEY, enabled ? '1' : '0');
            } catch (err) {
                // Ignore storage failures.
            }
        }

        function parseTargetReportingEnabled(value) {
            if (value === true || value === 'ON') return true;
            if (value === false || value === 'OFF') return false;
            const raw = String(value || '').trim().toLowerCase();
            if (!raw) return false;
            if (raw.includes('disable')) return false;
            if (raw.includes('enable')) return true;
            return false;
        }

        function setTargetReportingState(enabled, rawValue) {
            const isEnabled = !!enabled;
            if (targetReportToggle) {
                targetReportToggle.checked = isEnabled;
            }
            if (targetReportState) {
                targetReportState.textContent = isEnabled ? 'ON' : 'OFF';
                targetReportState.classList.toggle('target-report-state-on', isEnabled);
                targetReportState.classList.toggle('target-report-state-off', !isEnabled);
            }
            if (targetReportValueLabel) {
                const normalized = String(rawValue || '').trim();
                targetReportValueLabel.textContent = normalized || (isEnabled ? 'Enable' : 'Disable');
            }
        }

        function syncTargetReportingAutoOffPreference() {
            const enabled = targetReportAutoOffToggle ? !!targetReportAutoOffToggle.checked : false;
            socket.emit('set_reporting_auto_off', { enabled: enabled });
            if (window.SwitchStudioState) {
                window.SwitchStudioState.setPacketStatus('info', enabled ? 'Auto-off armed on disconnect' : 'Auto-off disabled');
            }
        }

        if (targetReportAutoOffToggle) {
            targetReportAutoOffToggle.checked = getStoredTargetReportingAutoOff();
            targetReportAutoOffToggle.addEventListener('change', () => {
                persistTargetReportingAutoOff(!!targetReportAutoOffToggle.checked);
                syncTargetReportingAutoOffPreference();
            });
        }

        if (targetReportToggle) {
            targetReportToggle.addEventListener('change', () => {
                const enabled = !!targetReportToggle.checked;
                const requestId = `target-report-${Date.now()}`;
                socket.emit('set_target_reporting', { enabled: enabled, request_id: requestId });
                if (window.SwitchStudioState) {
                    window.SwitchStudioState.setPacketStatus('syncing', enabled ? 'Enabling target reporting...' : 'Disabling target reporting...');
                } else {
                    packetInfo.innerText = enabled ? 'Enabling target reporting...' : 'Disabling target reporting...';
                }
            });
        }
        setTargetReportingState(false, 'Disable');

        function getInputValueForEmit(input) {
            if (!input) return '';
            if (input.type === 'checkbox') return input.checked;

            const fieldType = input.dataset.fieldType;
            if (fieldType === 'numeric') {
                if (input.value === '') return '';
                const parsed = Number(input.value);
                return Number.isFinite(parsed) ? parsed : input.value;
            }

            if (fieldType === 'list') {
                const raw = (input.value || '').trim();
                if (!raw) return [];
                const itemType = input.dataset.itemType || '';
                return raw
                    .split(',')
                    .map(v => v.trim())
                    .filter(Boolean)
                    .map(v => {
                        if (itemType === 'numeric') {
                            const n = Number(v);
                            return Number.isFinite(n) ? n : v;
                        }
                        return v;
                    });
            }

            return input.value;
        }

        const friendlyLabelMap = {
            // Presence & Zones
            mmwaveControlWiredDevice: 'Presence -> Light Behavior',
            mmWaveRoomSizePreset: 'Room Size Preset',
            mmWaveHoldTime: 'Vacancy Timeout',
            mmWaveDetectSensitivity: 'Presence Sensitivity',
            mmWaveDetectTrigger: 'Detection Response Speed',
            mmWaveTargetInfoReport: 'Live Position Reporting',
            mmWaveStayLife: 'Stationary Detection Duration',
            mmWaveHeightMin: 'Height Min (Z)',
            mmWaveHeightMax: 'Height Max (Z)',
            mmWaveWidthMin: 'Width Min (X)',
            mmWaveWidthMax: 'Width Max (X)',
            mmWaveDepthMin: 'Depth Min (Y)',
            mmWaveDepthMax: 'Depth Max (Y)',
            mmwave_control_commands: 'mmWave Commands (Advanced)',
            mmwave_interference_areas: 'Interference Zones (Advanced)',
            mmwave_detection_areas: 'Detection Zones (Advanced)',
            mmwave_stay_areas: 'Stay Zones (Advanced)',

            // Load & Dimming
            dimmingSpeedUpRemote: 'Dim Up Speed (Hub)',
            dimmingSpeedUpLocal: 'Dim Up Speed (Paddle)',
            rampRateOffToOnRemote: 'Ramp On Speed (Hub)',
            rampRateOffToOnLocal: 'Ramp On Speed (Paddle)',
            dimmingSpeedDownRemote: 'Dim Down Speed (Hub)',
            dimmingSpeedDownLocal: 'Dim Down Speed (Paddle)',
            rampRateOnToOffRemote: 'Ramp Off Speed (Hub)',
            rampRateOnToOffLocal: 'Ramp Off Speed (Paddle)',
            invertSwitch: 'Invert Paddle Direction',
            autoTimerOff: 'Auto-Off Timer',
            defaultLevelLocal: 'Default Level (Paddle)',
            defaultLevelRemote: 'Default Level (Hub)',
            stateAfterPowerRestored: 'Power Restore State',
            loadLevelIndicatorTimeout: 'Level Indicator Timeout',
            switchType: 'Wiring Type',
            smartBulbMode: 'Smart Bulb Mode',
            bindingOffToOnSyncLevel: 'Bind Uses Default Level',
            minimumLevel: 'Minimum Dim Level',
            maximumLevel: 'Maximum Dim Level',
            outputMode: 'Switch Mode (Dimmer / On-Off)',
            quickStartTime: 'Quick Start Time',
            quickStartLevel: 'Quick Start Level',
            higherOutputInNonNeutral: 'Unthrottled Output (No Neutral)',

            // LED & Notifications
            led_effect: 'LED Effect (All LEDs)',
            individual_led_effect: 'LED Effect (Single LED)',
            ledColorWhenOn: 'All LEDs Color (On)',
            ledColorWhenOff: 'All LEDs Color (Off)',
            ledIntensityWhenOn: 'All LEDs Brightness (On)',
            ledIntensityWhenOff: 'All LEDs Brightness (Off)',
            ledColorForFanControlMode: 'Fan Mode LED Color',
            onOffLedMode: 'Single LED Mode (Bottom Only)',
            firmwareUpdateInProgressIndicator: 'Firmware Progress LED',
            doubleTapClearNotifications: 'Double-Tap Clears Notifications',
            fanLedLevelType: 'Fan LED Display Mode',
            ledBarScaling: 'LED Bar Scaling (Gen 2 Match)',
            defaultLed1ColorWhenOn: 'LED 1 Color (On)',
            defaultLed1ColorWhenOff: 'LED 1 Color (Off)',
            defaultLed1IntensityWhenOn: 'LED 1 Brightness (On)',
            defaultLed1IntensityWhenOff: 'LED 1 Brightness (Off)',
            defaultLed2ColorWhenOn: 'LED 2 Color (On)',
            defaultLed2ColorWhenOff: 'LED 2 Color (Off)',
            defaultLed2IntensityWhenOn: 'LED 2 Brightness (On)',
            defaultLed2IntensityWhenOff: 'LED 2 Brightness (Off)',
            defaultLed3ColorWhenOn: 'LED 3 Color (On)',
            defaultLed3ColorWhenOff: 'LED 3 Color (Off)',
            defaultLed3IntensityWhenOn: 'LED 3 Brightness (On)',
            defaultLed3IntensityWhenOff: 'LED 3 Brightness (Off)',
            defaultLed4ColorWhenOn: 'LED 4 Color (On)',
            defaultLed4ColorWhenOff: 'LED 4 Color (Off)',
            defaultLed4IntensityWhenOn: 'LED 4 Brightness (On)',
            defaultLed4IntensityWhenOff: 'LED 4 Brightness (Off)',
            defaultLed5ColorWhenOn: 'LED 5 Color (On)',
            defaultLed5ColorWhenOff: 'LED 5 Color (Off)',
            defaultLed5IntensityWhenOn: 'LED 5 Brightness (On)',
            defaultLed5IntensityWhenOff: 'LED 5 Brightness (Off)',
            defaultLed6ColorWhenOn: 'LED 6 Color (On)',
            defaultLed6ColorWhenOff: 'LED 6 Color (Off)',
            defaultLed6IntensityWhenOn: 'LED 6 Brightness (On)',
            defaultLed6IntensityWhenOff: 'LED 6 Brightness (Off)',
            defaultLed7ColorWhenOn: 'LED 7 Color (On)',
            defaultLed7ColorWhenOff: 'LED 7 Color (Off)',
            defaultLed7IntensityWhenOn: 'LED 7 Brightness (On)',
            defaultLed7IntensityWhenOff: 'LED 7 Brightness (Off)',
            notificationComplete: 'Last Notification Cleared',

            // Buttons & Scenes
            buttonDelay: 'Multi-Tap Delay',
            doubleTapUpToParam55: 'Enable Double-Tap Up',
            doubleTapDownToParam56: 'Enable Double-Tap Down',
            brightnessLevelForDoubleTapUp: 'Double-Tap Up Level',
            brightnessLevelForDoubleTapDown: 'Double-Tap Down Level',
            singleTapBehavior: 'Single-Tap Behavior (Fan Mode)',
            auxSwitchUniqueScenes: 'Aux Unique Scenes',

            // Power & Device
            fanControlMode: 'Fan Control Mode',
            lowLevelForFanControlMode: 'Fan Low Level',
            mediumLevelForFanControlMode: 'Fan Medium Level',
            highLevelForFanControlMode: 'Fan High Level',
            fanTimerMode: 'Fan Timer Mode',
            localProtection: 'Local Control Lock',
            activePowerReports: 'Power Report Threshold',
            periodicPowerAndEnergyReports: 'Periodic Report Interval',
            activeEnergyReports: 'Energy Report Threshold',
            otaImageType: 'OTA Image Type',
            identify: 'Identify Device',
            energy_reset: 'Reset Energy Counter',

            // Runtime Options
            power_calibration: 'Power Calibration (%)',
            power_precision: 'Power Precision',
            voltage_calibration: 'Voltage Calibration (%)',
            voltage_precision: 'Voltage Precision',
            current_calibration: 'Current Calibration (%)',
            current_precision: 'Current Precision',
            energy_calibration: 'Energy Calibration (%)',
            energy_precision: 'Energy Precision',
            illuminance_calibration: 'Illuminance Calibration',
            transition: 'Transition Time',
            identify_timeout: 'Identify Timeout',
            state_action: 'Publish Action Events',
            illuminance_raw: 'Publish Raw Illuminance',
            no_occupancy_since: 'Vacancy Alert Intervals',

            // Read-only
            mmWaveVersion: 'mmWave Firmware Version',
            dimmingMode: 'Dimming Method (Leading / Trailing)',
            remoteProtection: 'Remote Control Lock',
            powerType: 'Wiring Detection (Neutral / Non-Neutral)',
            internalTemperature: 'Internal Temperature',
            overheat: 'Overheat Status',
            deviceBindNumber: 'Bound Device Count',

            // Live state
            occupancy: 'Presence Detected',
            illuminance: 'Ambient Light (lux)',
            power: 'Active Power (W)',
            voltage: 'Line Voltage (V)',
            current: 'Current Draw (A)',
            energy: 'Total Energy (kWh)',
            action: 'Last Scene Event',
            linkquality: 'Zigbee Link Quality',
            area1Occupancy: 'Area 1 Presence',
            area2Occupancy: 'Area 2 Presence',
            area3Occupancy: 'Area 3 Presence',
            area4Occupancy: 'Area 4 Presence',

            // Composite features
            effect: 'Effect Pattern',
            color: 'Color Preset',
            level: 'Brightness',
            duration: 'Duration',
            led: 'Target LED',
            command: 'mmWave Command',
            area1: 'Area 1',
            area2: 'Area 2',
            area3: 'Area 3',
            area4: 'Area 4'
        };

        const compositeFeatureLabelOverrides = {
            led_effect: {
                effect: 'Effect Pattern',
                color: 'Color Preset',
                level: 'Brightness',
                duration: 'Duration'
            },
            individual_led_effect: {
                led: 'Target LED',
                effect: 'Effect Pattern',
                color: 'Color Preset',
                level: 'Brightness',
                duration: 'Duration'
            },
            mmwave_control_commands: {
                command: 'mmWave Command'
            },
            mmwave_interference_areas: {
                area1: 'Area 1',
                area2: 'Area 2',
                area3: 'Area 3',
                area4: 'Area 4'
            },
            mmwave_detection_areas: {
                area1: 'Area 1',
                area2: 'Area 2',
                area3: 'Area 3',
                area4: 'Area 4'
            },
            mmwave_stay_areas: {
                area1: 'Area 1',
                area2: 'Area 2',
                area3: 'Area 3',
                area4: 'Area 4'
            }
        };

        const enumOptionLabelOverrides = {
            invertSwitch: {
                Yes: 'Yes - Inverted (Up = Off)',
                No: 'No - Normal (Up = On)'
            },
            smartBulbMode: {
                Disabled: 'Disabled',
                'Smart Bulb Mode': 'Enabled'
            },
            onOffLedMode: {
                All: 'All LEDs',
                One: 'Bottom LED Only'
            },
            doubleTapClearNotifications: {
                'Enabled (Default)': 'Enabled',
                Disabled: 'Disabled'
            },
            higherOutputInNonNeutral: {
                'Disabled (default)': 'Disabled',
                Enabled: 'Enabled'
            },
            mmWaveTargetInfoReport: {
                'Disable (default)': 'Disable',
                Enable: 'Enable'
            },
            ledBarScaling: {
                'Gen3 method (VZM-style)': 'Gen 3 (VZM style)',
                'Gen2 method (LZW-style)': 'Gen 2 (LZW style)'
            }
        };

        function looksHumanReadableLabel(label) {
            const text = String(label || '').trim();
            if (!text) return false;
            if (text.includes(' ')) return true;
            return !/[a-z][A-Z]/.test(text);
        }

        function humanizeSchemaKey(name) {
            if (!name) return '';
            let text = String(name)
                .replace(/_/g, ' ')
                .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
                .replace(/([A-Za-z])([0-9])/g, '$1 $2')
                .replace(/([0-9])([A-Za-z])/g, '$1 $2')
                .replace(/\s+/g, ' ')
                .trim();

            const tokens = text.split(' ').map(token => {
                const lower = token.toLowerCase();
                if (lower === 'led') return 'LED';
                if (lower === 'ota') return 'OTA';
                if (lower === 'id') return 'ID';
                if (lower === 'zigbee') return 'Zigbee';
                if (/^\d+$/.test(token)) return token;
                return lower.charAt(0).toUpperCase() + lower.slice(1);
            });

            text = tokens.join(' ');
            text = text.replace(/\bMm Wave\b/g, 'mmWave');
            return text;
        }

        function getFriendlyLabel(name, fallbackLabel) {
            if (name && friendlyLabelMap[name]) return friendlyLabelMap[name];
            if (looksHumanReadableLabel(fallbackLabel)) return String(fallbackLabel).trim();
            if (name) return humanizeSchemaKey(name);
            return fallbackLabel || 'Unknown';
        }

        function getReadableFieldLabel(field) {
            if (!field) return 'Unknown';
            return getFriendlyLabel(field.name, field.label);
        }

        function getReadableFeatureLabel(parentField, feature) {
            if (!feature) return 'Unknown';
            const parentName = parentField && parentField.name ? parentField.name : '';
            const featureName = feature.name || '';
            const parentOverrides = parentName ? compositeFeatureLabelOverrides[parentName] : null;
            if (parentOverrides && featureName && parentOverrides[featureName]) {
                return parentOverrides[featureName];
            }
            return getFriendlyLabel(featureName, feature.label);
        }

        function getReadableEnumOptionLabel(fieldName, optionValue) {
            const raw = optionValue === undefined || optionValue === null ? '' : String(optionValue);
            if (!raw) return raw;
            const fieldOverrides = fieldName ? enumOptionLabelOverrides[fieldName] : null;
            if (fieldOverrides && Object.prototype.hasOwnProperty.call(fieldOverrides, raw)) {
                return fieldOverrides[raw];
            }
            return raw;
        }

        const defaultLedColorPresets = [
            { name: 'Red', value: 0 },
            { name: 'Orange', value: 21 },
            { name: 'Yellow', value: 42 },
            { name: 'Green', value: 85 },
            { name: 'Cyan', value: 127 },
            { name: 'Blue', value: 170 },
            { name: 'Violet', value: 212 },
            { name: 'Pink', value: 234 },
            { name: 'White', value: 255 }
        ];

        const concisePresenceDescriptions = {
            mmwaveControlWiredDevice: 'Choose how presence controls the wired load.',
            mmWaveRoomSizePreset: 'Pick a room profile, or use Custom for manual zone tuning.',
            mmWaveHoldTime: 'How long occupancy stays active after motion stops.',
            mmWaveDetectSensitivity: 'Sensitivity for movement detection.',
            mmWaveDetectTrigger: 'How quickly movement triggers occupancy.',
            mmWaveTargetInfoReport: 'Streams live target coordinates to the radar map.',
            mmWaveStayLife: 'Tuning value for stationary-presence retention.',
            mmWaveVersion: 'Current firmware version of the mmWave module.'
        };

        function isLedField(field) {
            if (!field) return false;
            const tabKey = mapFieldTabToKey(field, 'fields');
            if (tabKey === 'led') return true;
            const parentTab = String(field.parent_tab || '').toLowerCase();
            if (parentTab.includes('led')) return true;
            const parentName = String(field.parent_name || '').toLowerCase();
            if (parentName.includes('led')) return true;
            const fieldName = String(field.name || '').toLowerCase();
            return fieldName.includes('led') || fieldName.includes('notification');
        }

        function isLedColorField(field) {
            if (!field || field.type !== 'numeric' || !isLedField(field)) return false;
            return String(field.name || '').toLowerCase().includes('color');
        }

        function isLedBrightnessField(field) {
            if (!field || field.type !== 'numeric' || !isLedField(field)) return false;
            const name = String(field.name || '').toLowerCase();
            return name.includes('intensity') || name === 'level';
        }

        function fieldUsesSyncDefaultColor(field) {
            const name = String((field && field.name) || '').toLowerCase();
            if (/^defaultled[1-7]colorwhen(on|off)$/.test(name)) return true;
            const description = String((field && field.description) || '').toLowerCase();
            return description.includes('synchronization with default all led strip color parameter');
        }

        function normalizeColorPreset(preset) {
            if (!preset || preset.value === undefined || preset.value === null) return null;
            const numericValue = Number(preset.value);
            if (!Number.isFinite(numericValue)) return null;
            return {
                value: numericValue,
                name: preset.name ? String(preset.name) : `Value ${numericValue}`
            };
        }

        function getLedColorPresets(field) {
            const explicitPresets = Array.isArray(field && field.presets) ? field.presets.map(normalizeColorPreset).filter(Boolean) : [];
            if (explicitPresets.length > 0) return explicitPresets;

            if (fieldUsesSyncDefaultColor(field)) {
                return defaultLedColorPresets
                    .filter(preset => preset.value !== 255)
                    .concat([{ name: 'Sync Default', value: 255 }]);
            }

            return defaultLedColorPresets.slice();
        }

        function setLedColorSelectValue(select, value) {
            if (!select || select.tagName !== 'SELECT') return;
            const normalizedValue = value === undefined || value === null ? '' : String(value);

            Array.from(select.options)
                .filter(option => option.dataset.customColorValue === '1')
                .forEach(option => option.remove());

            if (!normalizedValue) {
                select.selectedIndex = -1;
                return;
            }

            const existingOption = Array.from(select.options).find(option => option.value === normalizedValue);
            if (existingOption) {
                select.value = normalizedValue;
                return;
            }

            const customOption = document.createElement('option');
            customOption.value = normalizedValue;
            customOption.textContent = `Current (${normalizedValue})`;
            customOption.dataset.customColorValue = '1';
            select.appendChild(customOption);
            select.value = normalizedValue;
        }

        function formatLedSliderValue(input) {
            if (!input) return '--';
            const rawValue = input.value === '' ? '--' : String(input.value);
            const maxValue = Number(input.max);
            if (rawValue !== '--' && maxValue === 101 && Number(rawValue) === 101) {
                return 'Sync';
            }
            return rawValue === '--' ? '--' : `${rawValue}%`;
        }

        function refreshLedSliderDisplay(input) {
            if (!input) return;
            const targetId = input.dataset.sliderValueTarget;
            if (!targetId) return;
            const valueElement = document.getElementById(targetId);
            if (!valueElement) return;
            valueElement.textContent = formatLedSliderValue(input);
        }

        function createLedColorPresetControl(field, inputId) {
            const select = document.createElement('select');
            select.className = 'control-select led-color-select';
            select.id = inputId;
            select.setAttribute('data-param', field.name);
            select.setAttribute('data-field-type', 'numeric');
            select.setAttribute('data-led-color-select', '1');

            getLedColorPresets(field).forEach(preset => {
                const option = document.createElement('option');
                option.value = String(preset.value);
                option.textContent = preset.name;
                select.appendChild(option);
            });
            return select;
        }

        function createLedBrightnessControl(field, inputId) {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-control';

            const input = document.createElement('input');
            input.type = 'range';
            input.id = inputId;
            input.setAttribute('data-param', field.name);
            input.setAttribute('data-field-type', 'numeric');
            input.setAttribute('data-led-brightness-slider', '1');
            if (field.value_min !== null && field.value_min !== undefined) input.min = field.value_min;
            if (field.value_max !== null && field.value_max !== undefined) input.max = field.value_max;
            if (field.value_step !== null && field.value_step !== undefined) input.step = field.value_step;
            else input.step = '1';
            if (field.value_min !== null && field.value_min !== undefined) input.value = String(field.value_min);

            const value = document.createElement('span');
            value.className = 'slider-value';
            value.id = `${inputId}__value`;
            input.dataset.sliderValueTarget = value.id;

            input.addEventListener('input', () => refreshLedSliderDisplay(input));
            input.addEventListener('change', () => refreshLedSliderDisplay(input));

            wrapper.appendChild(input);
            wrapper.appendChild(value);
            refreshLedSliderDisplay(input);
            return wrapper;
        }

        function getConciseLedDescription(field) {
            if (!field) return '';
            if (isLedColorField(field)) return 'Choose an LED color preset.';
            if (isLedBrightnessField(field)) return 'Adjust LED brightness.';
            return field.description || '';
        }

        function getConciseFieldDescription(field) {
            if (!field || !field.name) return field && field.description ? field.description : '';
            const tabKey = mapFieldTabToKey(field, 'fields');
            if (tabKey === 'presence') {
                return concisePresenceDescriptions[field.name] || field.description || '';
            }
            if (tabKey === 'led') {
                return getConciseLedDescription(field);
            }
            return field.description || '';
        }

        function mapFieldTabToKey(field, sourceType) {
            const tab = String((field && field.tab) || '').toLowerCase();
            if (tab === 'presence') return 'presence';
            if (tab === 'zones') return 'zones';
            if (tab === 'live') return 'live';
            if (tab === 'load & dimming') return 'load';
            if (tab === 'led & notifications') return 'led';
            if (tab === 'buttons & scenes') return 'buttons';
            if (tab === 'power & device') return 'power';
            if (tab === 'advanced') return 'power';
            if (sourceType === 'options') return 'power';
            return 'power';
        }

        const hiddenFieldKeys = new Set([
            // Controlled via dedicated top-level toggle card in the zones view.
            'mmWaveTargetInfoReport'
        ]);

        const fanFieldKeys = new Set([
            'fanControlMode',
            'fanTimerMode',
            'lowLevelForFanControlMode',
            'mediumLevelForFanControlMode',
            'highLevelForFanControlMode',
            'fanLedLevelType',
            'ledColorForFanControlMode',
            'singleTapBehavior'
        ]);

        const advancedFieldKeys = new Set([
            // Presence set-and-forget tuning.
            'mmWaveStayLife',
            'mmWaveHeightMin',
            'mmWaveHeightMax',
            'mmWaveWidthMin',
            'mmWaveWidthMax',
            'mmWaveDepthMin',
            'mmWaveDepthMax',

            // Load/switch setup parameters.
            'switchType',
            'outputMode',
            'invertSwitch',
            'smartBulbMode',
            'bindingOffToOnSyncLevel',
            'higherOutputInNonNeutral',
            'minimumLevel',
            'maximumLevel',
            'stateAfterPowerRestored',
            'autoTimerOff',
            'quickStartTime',
            'quickStartLevel',
            'localProtection',
            'otaImageType'
        ]);

        function isFieldHiddenByDedicatedControl(field) {
            return !!(field && field.name && hiddenFieldKeys.has(field.name));
        }

        function isFanField(field) {
            return !!(field && field.name && fanFieldKeys.has(field.name));
        }

        function isSetAndForgetField(field, sourceType) {
            if (!field || !field.name) return false;
            if (sourceType === 'options') return true;
            return advancedFieldKeys.has(field.name);
        }

        function createSchemaFieldInput(field, inputIdOverride) {
            const inputId = inputIdOverride || field.name;

            if (field.type === 'enum') {
                const select = document.createElement('select');
                select.className = 'control-select';
                select.id = inputId;
                select.setAttribute('data-param', field.name);
                select.setAttribute('data-field-type', field.type);
                (field.values || []).forEach(optionValue => {
                    const option = document.createElement('option');
                    option.value = optionValue;
                    option.textContent = getReadableEnumOptionLabel(field.name, optionValue);
                    select.appendChild(option);
                });
                return select;
            }

            if (field.type === 'binary') {
                const select = document.createElement('select');
                select.className = 'control-select';
                select.id = inputId;
                select.setAttribute('data-param', field.name);
                select.setAttribute('data-field-type', field.type);

                const onValue = field.value_on !== undefined ? field.value_on : true;
                const offValue = field.value_off !== undefined ? field.value_off : false;
                const entries = [
                    { value: onValue, label: `On (${String(onValue)})` },
                    { value: offValue, label: `Off (${String(offValue)})` }
                ];

                entries.forEach(entry => {
                    const option = document.createElement('option');
                    option.value = typeof entry.value === 'boolean' ? String(entry.value) : entry.value;
                    option.textContent = entry.label;
                    select.appendChild(option);
                });
                return select;
            }

            if (field.type === 'numeric') {
                if (isLedColorField(field)) {
                    return createLedColorPresetControl(field, inputId);
                }
                if (isLedBrightnessField(field)) {
                    return createLedBrightnessControl(field, inputId);
                }
                const input = document.createElement('input');
                input.type = 'number';
                input.id = inputId;
                input.setAttribute('data-param', field.name);
                input.setAttribute('data-field-type', field.type);
                if (field.value_min !== null && field.value_min !== undefined) input.min = field.value_min;
                if (field.value_max !== null && field.value_max !== undefined) input.max = field.value_max;
                if (field.value_step !== null && field.value_step !== undefined) input.step = field.value_step;
                return input;
            }

            if (field.type === 'list') {
                const input = document.createElement('input');
                input.type = 'text';
                input.id = inputId;
                input.className = 'full-width-select';
                input.placeholder = 'comma-separated values';
                input.setAttribute('data-param', field.name);
                input.setAttribute('data-field-type', field.type);
                if (field.item_type && field.item_type.type) {
                    input.setAttribute('data-item-type', field.item_type.type);
                }
                return input;
            }

            const unsupported = document.createElement('span');
            unsupported.className = 'zone-badge';
            unsupported.innerText = `Unsupported type: ${field.type || 'unknown'}`;
            return unsupported;
        }

        function createSchemaDescriptionRow(text, parent) {
            if (!text) return;
            const desc = document.createElement('div');
            desc.style.fontSize = '0.78em';
            desc.style.color = '#777';
            desc.style.marginTop = '-4px';
            desc.style.marginBottom = '8px';
            desc.textContent = text;
            parent.appendChild(desc);
        }

        function createReadOnlyValueElement(field) {
            const readOnlyVal = document.createElement('span');
            readOnlyVal.id = field.name;
            readOnlyVal.className = 'sensor-val';
            readOnlyVal.style.fontFamily = 'monospace';
            readOnlyVal.style.color = '#00bcd4';
            readOnlyVal.innerText = '--';
            return readOnlyVal;
        }

        function createSchemaFieldRow(field) {
            const row = document.createElement('div');
            row.className = 'input-row';

            const label = document.createElement('label');
            label.setAttribute('for', field.name);
            label.textContent = getReadableFieldLabel(field) + (field.unit ? ` (${field.unit})` : '') + ':';
            row.appendChild(label);

            if (field.can_write) {
                row.appendChild(createSchemaFieldInput(field));
            } else {
                row.appendChild(createReadOnlyValueElement(field));
            }
            return row;
        }

        function getCompositeFeatureInputId(fieldName, featureName) {
            return `${fieldName}__${featureName}`;
        }

        function resolveCompositeControlInput(control, inputId) {
            if (!control) return null;
            if (control.id === inputId) return control;
            if (typeof control.querySelector === 'function') {
                return control.querySelector(`[id="${inputId}"]`);
            }
            return null;
        }

        function createCompositeFeatureInput(parentField, feature) {
            const fieldName = parentField && parentField.name ? parentField.name : '';
            const featureField = {
                ...feature,
                name: feature.name,
                value_on: feature.value_on,
                value_off: feature.value_off,
                parent_tab: parentField ? parentField.tab : '',
                parent_name: fieldName,
            };
            const inputId = getCompositeFeatureInputId(fieldName, feature.name);
            const control = createSchemaFieldInput(featureField, inputId);
            const controlInput = resolveCompositeControlInput(control, inputId);
            if (controlInput) {
                controlInput.removeAttribute('data-param');
                controlInput.setAttribute('data-composite-parent', fieldName);
                controlInput.setAttribute('data-composite-feature', feature.name);
            }
            return control;
        }

        function collectCompositePayload(field) {
            const payload = {};
            const features = Array.isArray(field.features) ? field.features : [];

            for (const feature of features) {
                if (!feature || !feature.name || feature.type === 'composite') continue;
                const inputId = getCompositeFeatureInputId(field.name, feature.name);
                const input = document.getElementById(inputId);
                if (!input) continue;

                let value = getInputValueForEmit(input);
                if (feature.type === 'binary' && typeof value === 'string') {
                    if (value === 'true') value = true;
                    else if (value === 'false') value = false;
                }
                if (feature.type === 'numeric' && value === '') {
                    throw new Error(`${getReadableFeatureLabel(field, feature)} cannot be empty`);
                }

                const payloadKey = feature.property || feature.name;
                payload[payloadKey] = value;
            }
            return payload;
        }

        function sendCompositeUpdate(field) {
            try {
                const payload = collectCompositePayload(field);
                socket.emit('update_parameter', {
                    param: field.name,
                    value: payload,
                    request_id: `composite-${Date.now()}-${field.name}`
                });
                if (window.SwitchStudioState) {
                    window.SwitchStudioState.setPacketStatus('syncing', `${getReadableFieldLabel(field)} update sent`);
                    window.SwitchStudioState.showToast('syncing', `${getReadableFieldLabel(field)} update sent`, 1600);
                }
            } catch (err) {
                const message = err && err.message ? err.message : 'Failed to build composite payload';
                if (window.SwitchStudioState) {
                    window.SwitchStudioState.setPacketStatus('error', message);
                    window.SwitchStudioState.showToast('error', message, 2600);
                } else {
                    packetInfo.innerText = `Error: ${message}`;
                }
            }
        }

        function renderCompositeField(field, container) {
            const block = document.createElement('div');
            block.className = 'schema-composite-block';

            const title = document.createElement('div');
            title.className = 'schema-composite-title';
            title.textContent = getReadableFieldLabel(field);
            block.appendChild(title);

            const features = Array.isArray(field.features) ? field.features : [];
            if (features.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'schema-composite-note';
                empty.textContent = 'No editable features available for this composite.';
                block.appendChild(empty);
                container.appendChild(block);
                return;
            }

            features.forEach(feature => {
                if (!feature || !feature.name || feature.type === 'composite') return;
                const row = document.createElement('div');
                row.className = 'input-row';

                const label = document.createElement('label');
                label.setAttribute('for', getCompositeFeatureInputId(field.name, feature.name));
                label.textContent = `${getReadableFeatureLabel(field, feature)}${feature.unit ? ` (${feature.unit})` : ''}:`;
                row.appendChild(label);
                row.appendChild(createCompositeFeatureInput(field, feature));
                block.appendChild(row);
            });

            if (field.can_write) {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'cmd-btn btn-full';
                button.style.marginTop = '5px';
                button.innerText = `Send ${getReadableFieldLabel(field)}`;
                button.addEventListener('click', () => sendCompositeUpdate(field));
                block.appendChild(button);
            }

            if (field.description) {
                const note = document.createElement('div');
                note.className = 'schema-composite-note';
                note.textContent = field.description;
                block.appendChild(note);
            }

            container.appendChild(block);
        }

        function orderPresenceFields(fields) {
            const presenceNames = schemaModel && Array.isArray(schemaModel.mmwave_presence_fields)
                ? schemaModel.mmwave_presence_fields
                : [];
            const byName = new Map(fields.map(field => [field.name, field]));
            const ordered = [];
            const used = new Set();

            presenceNames.forEach(name => {
                const field = byName.get(name);
                if (field) {
                    ordered.push(field);
                    used.add(name);
                }
            });

            fields.forEach(field => {
                if (!used.has(field.name)) ordered.push(field);
            });
            return ordered;
        }

        function renderSchemaFieldCollection(container, fields, emptyMessage) {
            if (!container) return;
            container.innerHTML = '';

            if (!fields || fields.length === 0) {
                container.innerHTML = `<div style="font-size: 0.9em; color: #888;">${emptyMessage}</div>`;
                return;
            }

            const grouped = {};
            fields.forEach(field => {
                const section = field.section || 'General';
                if (!grouped[section]) grouped[section] = [];
                grouped[section].push(field);
            });

            Object.keys(grouped).forEach(section => {
                const sectionTitle = document.createElement('div');
                sectionTitle.className = 'schema-section-title';
                sectionTitle.textContent = section;
                container.appendChild(sectionTitle);

                grouped[section].forEach(field => {
                    schemaFieldMap[field.name] = field;

                    if (field.type === 'composite') {
                        schemaCompositeMap[field.name] = field;
                        renderCompositeField(field, container);
                        return;
                    }

                    container.appendChild(createSchemaFieldRow(field));
                    createSchemaDescriptionRow(getConciseFieldDescription(field), container);
                });
            });
        }

        function renderAllSchemaFields() {
            if (!schemaModel || !Array.isArray(schemaModel.fields)) {
                const unavailable = '<div style="font-size: 0.9em; color: #888;">Schema unavailable.</div>';
                if (schemaPresenceFields) schemaPresenceFields.innerHTML = unavailable;
                if (schemaLoadFields) schemaLoadFields.innerHTML = unavailable;
                if (schemaLedFields) schemaLedFields.innerHTML = unavailable;
                if (schemaButtonFields) schemaButtonFields.innerHTML = unavailable;
                if (schemaPowerFields) schemaPowerFields.innerHTML = unavailable;
                if (schemaAdvancedFields) schemaAdvancedFields.innerHTML = unavailable;
                if (schemaFanFields) schemaFanFields.innerHTML = unavailable;
                return;
            }

            schemaFieldMap = {};
            schemaCompositeMap = {};

            const fields = schemaModel.fields.filter(field => field && field.name);
            const options = Array.isArray(schemaModel.options) ? schemaModel.options.filter(opt => opt && opt.name) : [];

            const buckets = {
                presence: [],
                load: [],
                led: [],
                buttons: [],
                power: [],
                advanced: [],
                fan: []
            };

            fields.forEach(field => {
                if (isFieldHiddenByDedicatedControl(field)) return;

                if (isFanField(field)) {
                    buckets.fan.push({ ...field, section: 'Fan Parameters (May Not Apply)' });
                    return;
                }

                if (isSetAndForgetField(field, 'fields')) {
                    buckets.advanced.push({ ...field, section: field.section || 'Set-and-Forget' });
                    return;
                }

                const tabKey = mapFieldTabToKey(field, 'fields');
                if (tabKey === 'presence') buckets.presence.push(field);
                else if (tabKey === 'load') buckets.load.push(field);
                else if (tabKey === 'led') buckets.led.push(field);
                else if (tabKey === 'buttons') buckets.buttons.push(field);
                else if (tabKey === 'power') buckets.power.push(field);
            });

            const optionFields = options.map(option => ({ ...option, section: option.section || 'Runtime Options' }));
            buckets.advanced.push(...optionFields);

            const presenceFields = orderPresenceFields(buckets.presence);
            const loadFields = buckets.load;
            const ledFields = buckets.led;
            const buttonFields = buckets.buttons;
            const powerFields = buckets.power;
            const advancedFields = buckets.advanced;
            const fanFields = buckets.fan;

            renderSchemaFieldCollection(schemaPresenceFields, presenceFields, 'No presence controls found.');
            renderSchemaFieldCollection(schemaLoadFields, loadFields, 'No load or dimming controls found.');
            renderSchemaFieldCollection(schemaLedFields, ledFields, 'No LED fields found in schema.');
            renderSchemaFieldCollection(schemaButtonFields, buttonFields, 'No button or scene fields found.');
            renderSchemaFieldCollection(schemaPowerFields, powerFields, 'No power/device fields found.');
            renderSchemaFieldCollection(schemaAdvancedFields, advancedFields, 'No advanced settings found.');
            renderSchemaFieldCollection(schemaFanFields, fanFields, 'No fan-specific fields exposed for this device.');
        }

        function syncCompositeSchemaInputs(config) {
            if (!config || typeof config !== 'object') return;
            Object.entries(schemaCompositeMap).forEach(([fieldName, field]) => {
                if (!(fieldName in config)) return;
                const compositeValue = config[fieldName];
                if (!compositeValue || typeof compositeValue !== 'object') return;

                const features = Array.isArray(field.features) ? field.features : [];
                features.forEach(feature => {
                    if (!feature || !feature.name) return;
                    const inputId = getCompositeFeatureInputId(fieldName, feature.name);
                    const input = document.getElementById(inputId);
                    if (!input) return;

                    const key = feature.property || feature.name;
                    if (!(key in compositeValue)) return;
                    const value = compositeValue[key];

                    if (input.dataset.ledColorSelect === '1') {
                        setLedColorSelectValue(input, value);
                    } else if (input.type === 'checkbox') {
                        input.checked = value === true || value === 'ON' || value === 'true';
                    } else if (input.tagName === 'SELECT' && typeof value === 'boolean') {
                        input.value = String(value);
                    } else if (Array.isArray(value)) {
                        input.value = value.join(', ');
                    } else if (value !== undefined && value !== null) {
                        input.value = value;
                    } else {
                        input.value = '';
                    }

                    if (input.dataset.ledBrightnessSlider === '1') {
                        refreshLedSliderDisplay(input);
                    }
                });
            });
        }

        // Packet Aging Logic
        let lastPacketTime = null;
        
        setInterval(() => {
            if (lastPacketTime) {
                const age = (Date.now() - lastPacketTime) / 1000;
                packetAgeSpan.innerText = `(${age.toFixed(1)}s ago)`;
                if (age > 5) packetAgeSpan.style.color = '#ff5252';
                else if (age > 2) packetAgeSpan.style.color = '#ff9800';
                else packetAgeSpan.style.color = '#666';
            } else {
                packetAgeSpan.innerText = "";
            }
        }, 100);

        // Context-aware command tracking
        let lastCommandId = null; 

        // Helper: Collapse sidebars on mobile automatically
        function handleMobileView() {
            if (window.innerWidth <= 900) {
                document.querySelectorAll('.mobile-collapsed').forEach(el => el.removeAttribute('open'));
            } else {
                document.querySelectorAll('.mobile-collapsed').forEach(el => el.setAttribute('open', ''));
            }
        }
        window.addEventListener('load', handleMobileView);

        // Responsive Resize Handler
        window.addEventListener('resize', function() {
            Plotly.Plots.resize('chart');
            // Prevent mobile keyboard from triggering layout collapse
        });

        // Resize Plotly when chart is toggled open/closed
        document.getElementById('chartContainer').addEventListener('toggle', function(event) {
            if (event.target.open) {
                setTimeout(() => Plotly.Plots.resize('chart'), 50);
            }
        });

        // Helper: Update Timestamp
        function updateTimestamp() {
            const now = new Date();
            timestampSpan.innerText = now.toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second:'2-digit' }) + '.' + now.getMilliseconds().toString().padStart(3, '0');
            lastPacketTime = Date.now();
        }

        // --- Visualizer Settings Logic ---
        let showInterference = true;
        let showDetection = true;
        let showStay = true;
        let showGrid = true;
        let showLabels = true;
        let showZValues = false;
        
        // Individual Detection Toggles
        let showDetection1 = true;
        let showDetection2 = true;
        let showDetection3 = true;
        let showDetection4 = true;
        
        // Custom Scale Defaults
        let chartXMin = -650;
        let chartXMax = 650;
        let chartYMin = -50;
        let chartYMax = 650;

        // Init Settings from LocalStorage
        try {
            if (localStorage.getItem('vizShowInterference') !== null) showInterference = localStorage.getItem('vizShowInterference') === 'true';
            if (localStorage.getItem('vizShowDetection') !== null) showDetection = localStorage.getItem('vizShowDetection') === 'true';
            if (localStorage.getItem('vizShowStay') !== null) showStay = localStorage.getItem('vizShowStay') === 'true';
            if (localStorage.getItem('vizShowGrid') !== null) showGrid = localStorage.getItem('vizShowGrid') === 'true';
            if (localStorage.getItem('vizShowLabels') !== null) showLabels = localStorage.getItem('vizShowLabels') === 'true';
            if (localStorage.getItem('vizShowZValues') !== null) showZValues = localStorage.getItem('vizShowZValues') === 'true';
            
            // Sub detection toggles
            if (localStorage.getItem('vizShowDetection1') !== null) showDetection1 = localStorage.getItem('vizShowDetection1') === 'true';
            if (localStorage.getItem('vizShowDetection2') !== null) showDetection2 = localStorage.getItem('vizShowDetection2') === 'true';
            if (localStorage.getItem('vizShowDetection3') !== null) showDetection3 = localStorage.getItem('vizShowDetection3') === 'true';
            if (localStorage.getItem('vizShowDetection4') !== null) showDetection4 = localStorage.getItem('vizShowDetection4') === 'true';
            
            if (localStorage.getItem('vizXMin') !== null) chartXMin = parseInt(localStorage.getItem('vizXMin'));
            if (localStorage.getItem('vizXMax') !== null) chartXMax = parseInt(localStorage.getItem('vizXMax'));
            if (localStorage.getItem('vizYMin') !== null) chartYMin = parseInt(localStorage.getItem('vizYMin'));
            if (localStorage.getItem('vizYMax') !== null) chartYMax = parseInt(localStorage.getItem('vizYMax'));
        } catch(e) { console.log('Storage access error', e); }

        const vizToggleInterference = document.getElementById('vizToggleInterference');
        const vizToggleDetection = document.getElementById('vizToggleDetection');
        const vizToggleStay = document.getElementById('vizToggleStay');
        const vizToggleGrid = document.getElementById('vizToggleGrid');
        const vizToggleLabels = document.getElementById('vizToggleLabels');
        const vizToggleZValues = document.getElementById('vizToggleZValues');
        
        // Sub Toggles
        const vizToggleDetection1 = document.getElementById('vizToggleDetection1');
        const vizToggleDetection2 = document.getElementById('vizToggleDetection2');
        const vizToggleDetection3 = document.getElementById('vizToggleDetection3');
        const vizToggleDetection4 = document.getElementById('vizToggleDetection4');
        
        // Set inputs to loaded values
        vizXMin.value = chartXMin;
        vizXMax.value = chartXMax;
        vizYMin.value = chartYMin;
        vizYMax.value = chartYMax;

        function applyVizSettings() {
            // Set checkboxes
            if (vizToggleInterference) vizToggleInterference.checked = showInterference;
            if (vizToggleDetection) vizToggleDetection.checked = showDetection;
            if (vizToggleStay) vizToggleStay.checked = showStay;
            if (vizToggleGrid) vizToggleGrid.checked = showGrid;
            if (vizToggleLabels) vizToggleLabels.checked = showLabels;
            if (vizToggleZValues) vizToggleZValues.checked = showZValues;
            
            if (vizToggleDetection1) vizToggleDetection1.checked = showDetection1;
            if (vizToggleDetection2) vizToggleDetection2.checked = showDetection2;
            if (vizToggleDetection3) vizToggleDetection3.checked = showDetection3;
            if (vizToggleDetection4) vizToggleDetection4.checked = showDetection4;
            
            // Only update Plotly if the chart exists
            const chartDiv = document.getElementById('chart');
            if (chartDiv && chartDiv.layout) {
                // Update both shapes and annotations (labels)
                Plotly.relayout('chart', {
                    shapes: getChartShapes(),
                    annotations: getChartAnnotations()
                });
            }
        }
        
        function updateRadarScale() {
            chartXMin = parseInt(vizXMin.value);
            chartXMax = parseInt(vizXMax.value);
            chartYMin = parseInt(vizYMin.value);
            chartYMax = parseInt(vizYMax.value);
            
            localStorage.setItem('vizXMin', chartXMin);
            localStorage.setItem('vizXMax', chartXMax);
            localStorage.setItem('vizYMin', chartYMin);
            localStorage.setItem('vizYMax', chartYMax);
            
            const chartDiv = document.getElementById('chart');
            if (chartDiv && chartDiv.layout) {
                Plotly.relayout('chart', {
                    'xaxis.range': [chartXMin, chartXMax],
                    'yaxis.range': [chartYMin, chartYMax]
                });
            }
        }

        // Attach Listeners
        if (vizToggleInterference) vizToggleInterference.addEventListener('change', (e) => { showInterference = e.target.checked; localStorage.setItem('vizShowInterference', showInterference); applyVizSettings(); });
        if (vizToggleDetection) vizToggleDetection.addEventListener('change', (e) => { showDetection = e.target.checked; localStorage.setItem('vizShowDetection', showDetection); applyVizSettings(); });
        if (vizToggleStay) vizToggleStay.addEventListener('change', (e) => { showStay = e.target.checked; localStorage.setItem('vizShowStay', showStay); applyVizSettings(); });
        if (vizToggleGrid) vizToggleGrid.addEventListener('change', (e) => { showGrid = e.target.checked; localStorage.setItem('vizShowGrid', showGrid); applyVizSettings(); });
        if (vizToggleLabels) vizToggleLabels.addEventListener('change', (e) => { showLabels = e.target.checked; localStorage.setItem('vizShowLabels', showLabels); applyVizSettings(); });
        if (vizToggleZValues) vizToggleZValues.addEventListener('change', (e) => { showZValues = e.target.checked; localStorage.setItem('vizShowZValues', showZValues); applyVizSettings(); });

        if (vizToggleDetection1) vizToggleDetection1.addEventListener('change', (e) => { showDetection1 = e.target.checked; localStorage.setItem('vizShowDetection1', showDetection1); applyVizSettings(); });
        if (vizToggleDetection2) vizToggleDetection2.addEventListener('change', (e) => { showDetection2 = e.target.checked; localStorage.setItem('vizShowDetection2', showDetection2); applyVizSettings(); });
        if (vizToggleDetection3) vizToggleDetection3.addEventListener('change', (e) => { showDetection3 = e.target.checked; localStorage.setItem('vizShowDetection3', showDetection3); applyVizSettings(); });
        if (vizToggleDetection4) vizToggleDetection4.addEventListener('change', (e) => { showDetection4 = e.target.checked; localStorage.setItem('vizShowDetection4', showDetection4); applyVizSettings(); });

        // Radar Rings - Generate fresh objects
        function getRadarRings() {
            if (!showGrid) return []; // Grid Toggle

            const rings = [];
            rings.push({
                type: 'path',
                xref: 'x',
                yref: 'y',
                path: `M 0 0 L ${chartXMax} ${chartYMax} L ${chartXMin} ${chartYMax} Z`,
                fillcolor: 'rgba(0, 188, 212, 0.06)',
                line: { color: 'rgba(0, 188, 212, 0.0)', width: 0 },
                editable: false,
                layer: 'below'
            });
            [100, 200, 300, 400, 500, 600].forEach((dist) => {
                rings.push({
                    type: 'circle', xref: 'x', yref: 'y',
                    x0: -dist, x1: dist, y0: -dist, y1: dist,
                    line: { color: 'rgba(186, 221, 230, 0.14)', width: dist % 200 === 0 ? 1.2 : 1, dash: 'dot' },
                    editable: false,
                    layer: 'below'
                });
            });
            rings.push({
                type: 'line', xref: 'x', yref: 'y',
                x0: chartXMin, y0: 0, x1: chartXMax, y1: 0,
                line: { color: 'rgba(0, 188, 212, 0.35)', width: 1.4 },
                editable: false,
                layer: 'below'
            });
            rings.push({
                type: 'circle', xref: 'x', yref: 'y',
                x0: -18, x1: 18, y0: -18, y1: 18,
                fillcolor: 'rgba(255, 82, 82, 0.28)',
                line: { color: 'rgba(255, 82, 82, 0.65)', width: 1.4 },
                editable: false,
                layer: 'below'
            });
            rings.push({
                type: 'circle', xref: 'x', yref: 'y',
                x0: -8, x1: 8, y0: -8, y1: 8,
                fillcolor: 'rgba(255, 82, 82, 0.95)',
                line: { color: 'rgba(255, 255, 255, 0.85)', width: 1.2 },
                editable: false,
                layer: 'below'
            });
            return rings;
        }

        function getChartShapes() {
            let shapes = getRadarRings(); 
            let activeDraftShape = null;

            // Helper to decide opacity
            const getOpacity = (isTarget) => {
                if (!isEditingZone) return 0.6; // Normal opacity
                return isTarget ? 0.8 : 0.1;    // Highlight target, dim others
            };

            // 2. DETECTION AREAS
            if (showDetection) {
                Object.entries(deviceZones.mmwave_detection_areas).forEach(([areaId, config]) => {
                    // Check individual sub-toggles
                    let isVisible = true;
                    if (areaId === 'area1' && !showDetection1) isVisible = false;
                    if (areaId === 'area2' && !showDetection2) isVisible = false;
                    if (areaId === 'area3' && !showDetection3) isVisible = false;
                    if (areaId === 'area4' && !showDetection4) isVisible = false;

                    if (isVisible) {
                        const targetKey = `mmwave_detection_areas:${areaId}`;
                        const isArea1 = areaId === 'area1';
                        // Area 1 is Blue (Primary), others are Green (Secondary)
                        const color = isArea1 ? 'rgba(0, 188, 212, 0.8)' : 'rgba(76, 175, 80, 0.9)'; 
                        
                        if (isEditingZone && editingTarget === targetKey) {
                            if (draftZoneConfig) activeDraftShape = createShapeObj(draftZoneConfig, color, `rgba(0, 188, 212, 0.2)`, true);
                        } else if (config && !isEditingZone) {
                            shapes.push(createShapeObj(config, color.replace('0.8', '0.6').replace('0.9', '0.6'), color.replace('0.8', '0.1').replace('0.9', '0.1'), false));
                        }
                    }
                });
            }

            // 3. STAY AREAS (Orange)
            if (showStay) {
                Object.entries(deviceZones.mmwave_stay_areas).forEach(([areaId, config]) => {
                    const targetKey = `mmwave_stay_areas:${areaId}`;
                    if (isEditingZone && editingTarget === targetKey) {
                        if (draftZoneConfig) activeDraftShape = createShapeObj(draftZoneConfig, 'rgba(255, 152, 0, 0.9)', 'rgba(255, 152, 0, 0.2)', true);
                    } else if (config && !isEditingZone) {
                        shapes.push(createShapeObj(config, `rgba(255, 152, 0, 0.6)`, 'rgba(255, 152, 0, 0.1)', false));
                    }
                });
            }

            // 4. INTERFERENCE AREAS (Red)
            if (showInterference) {
                Object.entries(deviceZones.mmwave_interference_areas).forEach(([areaId, config]) => {
                    const targetKey = `mmwave_interference_areas:${areaId}`;
                    if (isEditingZone && editingTarget === targetKey) {
                        if (draftZoneConfig) activeDraftShape = createShapeObj(draftZoneConfig, 'rgba(255, 82, 82, 0.9)', 'rgba(255, 82, 82, 0.3)', true);
                    } else if (config && !isEditingZone) {
                        shapes.push(createShapeObj(config, `rgba(255, 82, 82, 0.6)`, 'rgba(255, 82, 82, 0.2)', false));
                    }
                });
            }

            // CRITICAL FIX: Push the active editable shape LAST so it is drawn ON TOP
            if (activeDraftShape) {
                shapes.push(activeDraftShape);
            }

            return shapes;
        }

        // --- NEW: Generate Labels for Radar Shapes ---
        function getChartAnnotations() {
            // Label Toggle Check
            if (!showLabels) return [];
            // Don't show labels while editing
            if (isEditingZone) return []; 

            let annotations = [];

            // Helper to add label
            const addLabel = (config, text, color) => {
                if (config) {
                    let labelText = text;
                    if (showZValues) {
                        labelText += `<br>Z: ${config.z_min}-${config.z_max}`;
                    }

                    annotations.push({
                        x: (config.x_min + config.x_max) / 2,
                        y: (config.y_min + config.y_max) / 2,
                        xref: 'x', yref: 'y',
                        text: labelText,
                        showarrow: false,
                        font: { color: 'white', size: 12, family: 'sans-serif', weight: 'bold' },
                        bgcolor: color,
                        borderpad: 2,
                        opacity: 0.9
                    });
                }
            };

            if (showDetection) {
                Object.entries(deviceZones.mmwave_detection_areas).forEach(([areaId, config]) => {
                    // Check individual sub-toggles
                    let isVisible = true;
                    if (areaId === 'area1' && !showDetection1) isVisible = false;
                    if (areaId === 'area2' && !showDetection2) isVisible = false;
                    if (areaId === 'area3' && !showDetection3) isVisible = false;
                    if (areaId === 'area4' && !showDetection4) isVisible = false;

                    if (isVisible) {
                        const isArea1 = areaId === 'area1';
                        const num = areaId.replace('area', '');
                        const label = isArea1 ? "D1 (Primary)" : `D${num}`;
                        // Use Blue for Area 1 label background
                        const color = isArea1 ? 'rgba(0, 188, 212, 0.8)' : 'rgba(76, 175, 80, 0.8)';
                        addLabel(config, label, color);
                    }
                });
            }

            if (showStay) {
                Object.entries(deviceZones.mmwave_stay_areas).forEach(([areaId, config]) => {
                    const num = areaId.replace('area', '');
                    addLabel(config, `S${num}`, 'rgba(255, 152, 0, 0.8)');
                });
            }

            if (showInterference) {
                Object.entries(deviceZones.mmwave_interference_areas).forEach(([areaId, config]) => {
                    const num = areaId.replace('area', '');
                    addLabel(config, `I${num}`, 'rgba(255, 82, 82, 0.8)');
                });
            }

            return annotations;
        }

        function createShapeObj(config, lineColor, fillColor, isEditable) {
            return {
                type: 'rect', 
                x0: config.x_min, x1: config.x_max, 
                y0: config.y_min, y1: config.y_max,
                line: { color: lineColor, width: 2, dash: isEditable ? 'dot' : 'solid' },
                fillcolor: fillColor,
                editable: isEditable
            };
        }

        function sendCommand(actionId) {
            socket.emit('send_command', actionId);

            if (zoneModule && typeof zoneModule.setPendingCommand === 'function') {
                zoneModule.setPendingCommand(actionId);
                return;
            }

            // Fallback expectation
            if (actionId === 1 || actionId === 3) {
                lastCommandId = actionId;
                if (window.SwitchStudioState) {
                    window.SwitchStudioState.setPacketStatus('syncing', actionId === 1 ? "Scanning for interference..." : "Clearing interference zones...");
                } else {
                    packetInfo.innerText = actionId === 1 ? "Scanning for interference..." : "Clearing interference zones...";
                }
            }
        }

        function handleForceSyncClick() {
            if (isEditingZone) {
                cancelZoneEdit();
            }
            socket.emit('request_devices');
            socket.emit('force_sync');
            if (window.SwitchStudioState) {
                window.SwitchStudioState.setPacketStatus('syncing', 'Syncing...');
            } else {
                packetInfo.innerText = 'Syncing...';
            }
        }

        configSidebar.addEventListener('change', function(event) {
            const input = event.target;
            if (!input || !(input.matches('input') || input.matches('select'))) return;
            if (!input.id) return;

            // Skip non-device config controls
            if (input.id.startsWith('viz') || input.id.startsWith('zoneEditor') || input.id.startsWith('edit')) return;

            const param = input.getAttribute('data-param');
            if (!param) return;

            let value = getInputValueForEmit(input);
            const fieldMeta = schemaFieldMap[param];
            if (fieldMeta && fieldMeta.type === 'binary' && typeof value === 'string') {
                if (value === 'true') value = true;
                else if (value === 'false') value = false;
            }

            if (window.SwitchStudioState && typeof window.SwitchStudioState.queueChange === 'function') {
                window.SwitchStudioState.queueChange(param, value, input);
                window.SwitchStudioState.setPacketStatus('info', 'Pending changes');
                return;
            }

            socket.emit('update_parameter', { param: param, value: value, request_id: `ui-${Date.now()}-${param}` });
        });

        // --- SOCKET EVENT HANDLERS ---
        socket.on('connect', () => {
            socket.emit('request_devices');
            socket.emit('request_schema');
            syncTargetReportingAutoOffPreference();
        });

        socket.on('schema_model', function(schema) {
            schemaModel = schema || null;
            renderAllSchemaFields();
        });

        socket.on('command_result', function(result) {
            if (!result || !result.status) return;
            if (zoneModule && typeof zoneModule.handleCommandResult === 'function') {
                zoneModule.handleCommandResult(result);
            }

            if (result.action === 'set_target_reporting') {
                const payload = result.payload || {};
                if (result.status === 'error') {
                    // Revert the toggle on errors so the UI reflects actual device state.
                    if (targetReportToggle) targetReportToggle.checked = !targetReportToggle.checked;
                    if (window.SwitchStudioState) {
                        window.SwitchStudioState.setPacketStatus('error', result.message ? `Error: ${result.message}` : 'Target reporting update failed');
                    } else {
                        packetInfo.innerText = result.message ? `Error: ${result.message}` : 'Target reporting update failed';
                    }
                } else if (result.status === 'sent') {
                    const enabled = !!payload.enabled;
                    setTargetReportingState(enabled, payload.value);
                    if (window.SwitchStudioState) {
                        window.SwitchStudioState.showToast('saved', enabled ? 'Target reporting enabled' : 'Target reporting disabled', 1500);
                    }
                }
            }

            if (window.SwitchStudioState && typeof window.SwitchStudioState.handleCommandResult === 'function') {
                window.SwitchStudioState.handleCommandResult(result);
            } else {
                if (result.status === 'error') {
                    packetInfo.innerText = result.message ? `Error: ${result.message}` : "Command failed";
                    return;
                }
                if (result.action === 'update_parameter' && result.status === 'sent') {
                    packetInfo.innerText = "Setting updated";
                }
            }
        });
        
        socket.on('device_list', function(devices) {
            const currentSelection = deviceSelect.value;
            deviceSelect.innerHTML = '<option value="" disabled selected>Select an Inovelli Switch</option>';
            devices.forEach(device => {
                const option = document.createElement('option');
                option.value = device.topic; option.text = device.friendly_name;
                deviceSelect.appendChild(option);
            });
            if (currentSelection) deviceSelect.value = currentSelection;
            // else deviceSelect.selectedIndex = 0; // Don't auto-select to prevent confusion
        });

        deviceSelect.addEventListener('change', function() {
            socket.emit('change_device', this.value);
            
            // FIRE A FORCE SYNC TO PREVENT STALE DATA ON LOAD
            socket.emit('force_sync'); 

            statusDiv.innerText = `Monitoring: ${this.options[this.selectedIndex].text}`;
            if (window.SwitchStudioState) {
                window.SwitchStudioState.resetForDeviceChange();
                window.SwitchStudioState.setPacketStatus('info', 'Awaiting data...');
            } else {
                packetInfo.innerText = "Awaiting data...";
            }
            timestampSpan.innerText = "--:--:--";
            packetAgeSpan.innerText = "";
            lastPacketTime = null;
            
            occupancyVal.innerText = "Waiting..."; occupancyVal.className = "sensor-val badge-clear";
            illuminanceVal.innerText = "-- lx";
            occupancyState = { global: null, area1: null, area2: null, area3: null, area4: null };
            
            // Reset Zone Indicators
            for(let i=1; i<=4; i++) {
                const badge = document.getElementById(`area${i}Val`);
                if(badge) { badge.innerText = "CLEAR"; badge.className = "zone-badge"; }
            }

            // Reset Visualization
            if (zoneModule && typeof zoneModule.resetHistory === 'function') {
                zoneModule.resetHistory();
            } else {
                targetHistory = {};
            }
            // Reset Zone Data
            deviceZones = {
                global: null,
                mmwave_detection_areas: { area1: null, area2: null, area3: null, area4: null },
                mmwave_interference_areas: { area1: null, area2: null, area3: null, area4: null },
                mmwave_stay_areas: { area1: null, area2: null, area3: null, area4: null }
            };
            
            // Cancel any active edits
            if (isEditingZone) cancelZoneEdit();

            Plotly.update('chart', {x: [[]], y: [[]], text: [[]]}, {shapes: getChartShapes(), annotations: []}); // Clear annotations on switch
            dataTableBody.innerHTML = '<tr><td colspan="5" class="no-data">No targets detected</td></tr>';
            nonMmwaveWarning.style.display = 'none'; 
        });

        // Helper: Convert Z2M area object to internal format and handle zeroed-out zones
        function parseZ2MArea(area) {
            if (!area) return null;
            
            let x0, x1, y0, y1, z0, z1;
            
            // Handle Z2M format (width_min) vs Raw Packet format (x_min)
            if ('width_min' in area) {
                x0 = area.width_min; x1 = area.width_max;
                y0 = area.depth_min; y1 = area.depth_max;
            } else if ('x_min' in area) {
                x0 = area.x_min; x1 = area.x_max;
                y0 = area.y_min; y1 = area.y_max;
            } else {
                return null;
            }
            
            // Handle Z (Height) - Check various common keys
            if ('height_min' in area) {
                 z0 = area.height_min; z1 = area.height_max;
            } else if ('z_min' in area) {
                 z0 = area.z_min; z1 = area.z_max;
            } else {
                 z0 = -300; z1 = 300; // Updated Default height per Inovelli specs
            }

            // Treat strictly zeroed zones as disabled/null (ignore Z for this check as partials might lack it)
            if (x0 === 0 && x1 === 0 && y0 === 0 && y1 === 0) return null;
            
            return { x_min: x0, x_max: x1, y_min: y0, y_max: y1, z_min: z0, z_max: z1 };
        }

        // --- FULL DEVICE CONFIGURATION & SENSORS ---
        socket.on('device_config', function(msg) {
            // Unpack wrapper
            if (!msg.topic || !msg.payload) return;
            const config = msg.payload;
            
            // FILTER: IGNORE DATA FROM OTHER DEVICES
            if (msg.topic !== deviceSelect.value) return;

            updateTimestamp(); 

            // 1. PARSE ZONES FOR VISUALIZATION
            if ("mmWaveWidthMin" in config) {
                 // Global Zone Config update
                 // Note: we might receive partial updates, so we need to merge
                 if (!deviceZones.mmwave_detection_areas.area1) deviceZones.mmwave_detection_areas.area1 = { x_min: -100, x_max: 100, y_min: 0, y_max: 600, z_min: -300, z_max: 300 }; // Default
                 if ("mmWaveWidthMin" in config) deviceZones.mmwave_detection_areas.area1.x_min = parseInt(config.mmWaveWidthMin);
                 if ("mmWaveWidthMax" in config) deviceZones.mmwave_detection_areas.area1.x_max = parseInt(config.mmWaveWidthMax);
                 if ("mmWaveDepthMin" in config) deviceZones.mmwave_detection_areas.area1.y_min = parseInt(config.mmWaveDepthMin);
                 if ("mmWaveDepthMax" in config) deviceZones.mmwave_detection_areas.area1.y_max = parseInt(config.mmWaveDepthMax);
            }

            if ("mmwave_detection_areas" in config) {
                const areas = config.mmwave_detection_areas || {}; 
                for (let i=1; i<=4; i++) deviceZones.mmwave_detection_areas[`area${i}`] = parseZ2MArea(areas[`area${i}`]);
            }
            if ("mmwave_interference_areas" in config) {
                 const areas = config.mmwave_interference_areas || {}; 
                for (let i=1; i<=4; i++) deviceZones.mmwave_interference_areas[`area${i}`] = parseZ2MArea(areas[`area${i}`]);
                
                // If we just cleared interference, finish status
                const pendingCommandId = zoneModule && typeof zoneModule.getPendingCommandId === 'function'
                    ? zoneModule.getPendingCommandId()
                    : lastCommandId;
                if (pendingCommandId === 3 && (!config.mmwave_interference_areas || Object.keys(config.mmwave_interference_areas).length === 0)) {
                    if (window.SwitchStudioState) {
                        window.SwitchStudioState.setPacketStatus('saved', 'Interference cleared');
                    } else {
                        packetInfo.innerText = "Interference Cleared";
                    }
                    if (zoneModule && typeof zoneModule.clearPendingCommand === 'function') {
                        zoneModule.clearPendingCommand();
                    } else {
                        lastCommandId = null;
                    }
                }
            }
            if ("mmwave_stay_areas" in config) {
                 const areas = config.mmwave_stay_areas || {}; 
                for (let i=1; i<=4; i++) deviceZones.mmwave_stay_areas[`area${i}`] = parseZ2MArea(areas[`area${i}`]);
            }
            
            // Refresh chart to show new zones (unless editing)
            if (!isEditingZone) {
                Plotly.relayout('chart', {shapes: getChartShapes(), annotations: getChartAnnotations()});
            }

            // 2. UPDATE LIVE SENSORS
            if ("occupancy" in config) {
                const parsedGlobal = parseOccupancyValue(config.occupancy);
                if (parsedGlobal === true) {
                    occupancyVal.innerText = "DETECTED";
                    occupancyVal.className = "sensor-val badge-detected";
                    occupancyState.global = true;
                } else if (parsedGlobal === false) {
                    occupancyVal.innerText = "CLEAR";
                    occupancyVal.className = "sensor-val badge-clear";
                    occupancyState.global = false;
                }
            }
            if ("illuminance" in config) {
                illuminanceVal.innerText = `${config.illuminance} lx`;
            }
            if ("mmWaveTargetInfoReport" in config) {
                const enabled = parseTargetReportingEnabled(config.mmWaveTargetInfoReport);
                setTargetReportingState(enabled, config.mmWaveTargetInfoReport);
            }

            // Update Zone Status (mmwave_areaX_occupancy)
            for(let i=1; i<=4; i++) {
                const snakeKey = `mmwave_area${i}_occupancy`;
                const camelKey = `area${i}Occupancy`;
                const badge = document.getElementById(`area${i}Val`);
                let rawVal = null;
                if (snakeKey in config) rawVal = config[snakeKey];
                else if (camelKey in config) rawVal = config[camelKey];

                if(rawVal !== null && badge) {
                    const parsedArea = parseOccupancyValue(rawVal);
                    if(parsedArea === true) {
                        badge.innerText = "DETECTED";
                        badge.className = "zone-badge zone-active";
                        occupancyState[`area${i}`] = true;
                    } else if (parsedArea === false) {
                        badge.innerText = "CLEAR";
                        badge.className = "zone-badge";
                        occupancyState[`area${i}`] = false;
                    }
                }
            }

            if (!hasActiveOccupancy()) {
                clearTargetsForOccupancyGate();
            }

            // 3. CHECK DEVICE TYPE (Fixed: Allow partial updates)
            if ("mmWaveVersion" in config) {
                // If this packet HAS version, it's definitely mmWave. Clear warnings.
                nonMmwaveWarning.style.display = 'none';
                configSidebar.style.opacity = '1';
                configSidebar.style.pointerEvents = 'auto';
                btnForceSync.disabled = false;
            } else if (nonMmwaveWarning.style.display === 'block') {
                // If warning is already ON, leave it ON unless we get confirmation otherwise
            }
            // We removed the logic that forces Warning ON if version is missing, because partial updates (like occupancy) lack it.

            // 4. SYNC CONFIG INPUTS
            if (window.SwitchStudioState && typeof window.SwitchStudioState.syncConfig === 'function') {
                window.SwitchStudioState.syncConfig(config);
            } else {
                for (const [key, value] of Object.entries(config)) {
                    const element = document.getElementById(key);
                    if (element) {
                        if (element.tagName === 'SPAN') {
                            element.innerText = value;
                        } else if (element.dataset.ledColorSelect === '1') {
                            setLedColorSelectValue(element, value);
                        } else if (element.type === 'checkbox') {
                            element.checked = value === true || value === 'ON' || value === 'true';
                        } else {
                            element.value = value;
                        }
                        if (element.dataset.ledBrightnessSlider === '1') {
                            refreshLedSliderDisplay(element);
                        }
                    }
                }
            }
            syncCompositeSchemaInputs(config);
        });

        // --- PLOTLY INIT ---
        const layout = {
            paper_bgcolor: '#0f171c',
            plot_bgcolor: '#10242d',
            xaxis: {
                range: [chartXMin, chartXMax],
                title: 'X - Width (cm)',
                gridcolor: 'rgba(176, 214, 224, 0.12)',
                zerolinecolor: 'rgba(0, 188, 212, 0.35)',
                linecolor: 'rgba(129, 162, 172, 0.4)',
                tickfont: { color: '#bdd9df' },
                fixedrange: true
            },
            yaxis: {
                range: [chartYMin, chartYMax],
                title: 'Y - Depth (cm)',
                gridcolor: 'rgba(176, 214, 224, 0.12)',
                zerolinecolor: 'rgba(0, 188, 212, 0.35)',
                linecolor: 'rgba(129, 162, 172, 0.4)',
                tickfont: { color: '#bdd9df' },
                fixedrange: true
            },
            margin: { t: 10, b: 42, l: 46, r: 30 },
            font: { color: '#d9edf1' },
            showlegend: false,
            shapes: getChartShapes(),
            annotations: getChartAnnotations()
        };

        const chartConfig = {
            modeBarButtonsToRemove: ['select2d', 'lasso2d'], 
            displaylogo: false,
            scrollZoom: false, // Disabled by default until unlocked
            edits: {
                shapePosition: false // CRITICAL FIX: Initializes editability correctly
            },
            responsive: true // Enable internal Plotly responsiveness
        };

        Plotly.newPlot('chart', [
            {
                x: [],
                y: [],
                mode: 'markers+text',
                text: [],
                textposition: 'top center',
                marker: {
                    size: 12,
                    color: '#58d7f0',
                    line: { color: '#e3f8fd', width: 1.6 }
                },
                textfont: { color: '#d7f5fb' },
                type: 'scatter'
            },
            {
                x: [],
                y: [],
                mode: 'lines',
                line: { color: '#43cde8', width: 2 },
                opacity: 0.26,
                type: 'scatter'
            }
        ], layout, chartConfig);

        if (window.SwitchStudioZones && typeof window.SwitchStudioZones.init === 'function') {
            zoneModule = window.SwitchStudioZones.init({
                chartId: 'chart',
                dataTableBodyEl: dataTableBody,
                zoneStatusId: 'zoneStatus',
                commandLogEl: commandLog,
                stateApi: window.SwitchStudioState || null,
                updateTimestamp: updateTimestamp,
                getLayout: () => layout,
                getIsEditing: () => isEditingZone,
                getIsInteracting: () => isInteracting,
                historyLength: HISTORY_LENGTH,
                shouldRenderTargets: () => hasActiveOccupancy()
            });
        }
        
        // Initial Visualizer Settings Apply
        setTimeout(applyVizSettings, 100);

        socket.on('zone_config', function(msg) {
            // Unpack wrapper
            if (!msg.topic || !msg.payload) return;
            const config = msg.payload;
            
            // FILTER: IGNORE DATA FROM OTHER DEVICES
            if (msg.topic !== deviceSelect.value) return;
            
            // Map the global config to our internal object
            deviceZones.global = {
                x_min: config.x_min, x_max: config.x_max,
                y_min: config.y_min, y_max: config.y_max
            };
            
            if (!isEditingZone) Plotly.relayout('chart', {shapes: getChartShapes(), annotations: getChartAnnotations()});
        });

        // --- INTERFERENCE ZONE LOGIC (From Raw Packets) ---
        socket.on('interference_zones', function(msg) {
            // Unpack wrapper
            if (!msg.topic || !msg.payload) return;
            const zones = msg.payload;

            // FILTER: IGNORE DATA FROM OTHER DEVICES
            if (msg.topic !== deviceSelect.value) return;

            // Update our internal state from the raw packet data
            // Note: The backend sends an array. We try to map it to area1..4
            for (let i = 0; i < 4; i++) {
                const areaKey = `area${i + 1}`;
                if (zones[i]) {
                    // Raw packets Cmd 2 do not carry Z. Preserve existing Z if available.
                    const existingZMin = deviceZones.mmwave_interference_areas[areaKey]?.z_min || 0;
                    const existingZMax = deviceZones.mmwave_interference_areas[areaKey]?.z_max || 300;

                    const newArea = parseZ2MArea(zones[i]);
                    if (newArea) {
                        newArea.z_min = existingZMin;
                        newArea.z_max = existingZMax;
                        deviceZones.mmwave_interference_areas[areaKey] = newArea;
                    }
                } else {
                    deviceZones.mmwave_interference_areas[areaKey] = null;
                }
            }

            if (!isEditingZone) Plotly.relayout('chart', {shapes: getChartShapes(), annotations: getChartAnnotations()});

            if (zoneModule && typeof zoneModule.handleInterferenceZones === 'function') {
                zoneModule.handleInterferenceZones(zones);
            } else if (lastCommandId !== null) {
                const statusBox = document.getElementById('zoneStatus');
                statusBox.style.display = 'block';
                if (zones.length === 0) {
                    statusBox.style.background = 'rgba(76, 175, 80, 0.9)';
                    statusBox.innerText = 'Scan complete: no active interference found.';
                } else {
                    statusBox.style.background = 'rgba(255, 82, 82, 0.9)';
                    statusBox.innerText = `Auto-config complete: found ${zones.length} zone(s).`;
                }
                setTimeout(() => { statusBox.style.display = 'none'; }, 5000);
                lastCommandId = null;
            }
        });

        socket.on('detection_zones', function(msg) {
            if (!msg.topic || !msg.payload) return;
            const zones = msg.payload;
            if (msg.topic !== deviceSelect.value) return;

            for(let i=0; i<4; i++) {
                if (zones[i]) {
                    const newArea = parseZ2MArea(zones[i]);
                    if (newArea) {
                         // Use Z from packet if available, else default from parseZ2MArea
                         if (zones[i].z_min !== undefined) newArea.z_min = zones[i].z_min;
                         if (zones[i].z_max !== undefined) newArea.z_max = zones[i].z_max;
                         deviceZones.mmwave_detection_areas[`area${i+1}`] = newArea;
                    }
                } else {
                    deviceZones.mmwave_detection_areas[`area${i+1}`] = null;
                }
            }
            if (!isEditingZone) Plotly.relayout('chart', {shapes: getChartShapes(), annotations: getChartAnnotations()});
        });

        socket.on('stay_zones', function(msg) {
            if (!msg.topic || !msg.payload) return;
            const zones = msg.payload;
            if (msg.topic !== deviceSelect.value) return;

            for(let i=0; i<4; i++) {
                if (zones[i]) {
                    const newArea = parseZ2MArea(zones[i]);
                    if (newArea) {
                         if (zones[i].z_min !== undefined) newArea.z_min = zones[i].z_min;
                         if (zones[i].z_max !== undefined) newArea.z_max = zones[i].z_max;
                         deviceZones.mmwave_stay_areas[`area${i+1}`] = newArea;
                    }
                } else {
                    deviceZones.mmwave_stay_areas[`area${i+1}`] = null;
                }
            }
            if (!isEditingZone) Plotly.relayout('chart', {shapes: getChartShapes(), annotations: getChartAnnotations()});
        });

        socket.on('new_data', function(msg) {
            if (zoneModule && typeof zoneModule.handleNewData === 'function') {
                if (zoneModule.handleNewData(msg, deviceSelect.value)) return;
            }

            // Unpack wrapper
            if (!msg.topic || !msg.payload) return;
            const data = msg.payload;
            
            // FILTER: IGNORE DATA FROM OTHER DEVICES
            if (msg.topic !== deviceSelect.value) return;

            if (!hasActiveOccupancy()) {
                clearTargetsForOccupancyGate();
                return;
            }

            updateTimestamp();
            packetInfo.innerText = `Targets Visible: ${data.targets.length}`;
            packetInfo.style.color = '#00bcd4';
            
            const currentIds = new Set(data.targets.map(t => t.id));
            Object.keys(targetHistory).forEach(id => { if (!currentIds.has(Number(id))) delete targetHistory[id]; });

            data.targets.forEach(t => {
                if (!targetHistory[t.id]) targetHistory[t.id] = [];
                targetHistory[t.id].push({x: t.x, y: t.y});
                if (targetHistory[t.id].length > HISTORY_LENGTH) targetHistory[t.id].shift();
            });

            let historyX = [], historyY = [];
            Object.values(targetHistory).forEach(points => {
                points.forEach(p => { historyX.push(p.x); historyY.push(p.y); });
                historyX.push(null); historyY.push(null); 
            });

            const sizes = data.targets.map(t => Math.max(8, Math.min(40, 10 + (t.z / 5))));

            // CRITICAL JITTER FIX: If editing, use Plotly.restyle to ONLY update the points.
            // Do NOT touch the layout (shapes) or trigger a full redraw (Plotly.react).
            if (isEditingZone) {
                // IMPORTANT: If user is interacting (dragging), we SKIP updates entirely to prevent glitching
                if (isInteracting) return; 

                Plotly.restyle('chart', {
                    x: [data.targets.map(t => t.x), historyX],
                    y: [data.targets.map(t => t.y), historyY],
                    text: [data.targets.map(t => `ID: ${t.id} [Z:${t.z}cm]`), null],
                    'marker.size': [sizes, null]
                }, [0, 1]); // Update Trace 0 and 1
            } else {
                // Normal update
                Plotly.react('chart', [
                    {
                        x: data.targets.map(t => t.x),
                        y: data.targets.map(t => t.y),
                        text: data.targets.map(t => `ID: ${t.id} [Z:${t.z}cm]`),
                        mode: 'markers+text',
                        textposition: 'top center',
                        marker: { size: sizes, color: '#58d7f0', line: {color: '#e3f8fd', width: 1.6} },
                        textfont: { color: '#d7f5fb' },
                        type: 'scatter'
                    },
                    { x: historyX, y: historyY, mode: 'lines', line: {color: '#43cde8', width: 2}, opacity: 0.26, type: 'scatter' }
                ], layout);
            }

            if (data.targets.length === 0) {
                dataTableBody.innerHTML = '<tr><td colspan="5" class="no-data">Scanning for motion...</td></tr>';
                return;
            }

            dataTableBody.innerHTML = '';
            data.targets.forEach(t => {
                let dopStatus = "Stationary", dopColor = "#888";
                if (t.dop > 10) { dopStatus = `Moving Away (${t.dop})`; dopColor = "#ff9800"; }
                else if (t.dop < -10) { dopStatus = `Approaching (${t.dop})`; dopColor = "#4caf50"; }

                dataTableBody.innerHTML += `<tr><td style="font-weight: bold; color: #00bcd4;">${t.id}</td><td>${t.x} cm</td><td>${t.y} cm</td><td>${t.z} cm</td><td style="color: ${dopColor}; font-weight: bold;">${dopStatus}</td></tr>`;
            });
        });

        // --- INTERACTIVE ZONE EDITING ---

        // Start Edit Mode
        function startZoneEdit() {
            const target = zoneEditorSelect.value;
            if (!target) return;

            editingTarget = target;
            isEditingZone = true;
            btnStartEdit.style.display = 'none'; // Hide Start Button
            
            // Find existing config or create default
            let config = null;
            if (target === 'global') {
                config = deviceZones.global;
            } else {
                const [category, area] = target.split(':');
                config = deviceZones[category][area];
            }

            // If no existing config, create a default centered box with updated Z defaults
            if (!config) {
                config = { x_min: -100, x_max: 100, y_min: 50, y_max: 250, z_min: -300, z_max: 300 };
            }
            // Ensure Z exists (if config came from somewhere without it)
            if (config.z_min === undefined) config.z_min = -300;
            if (config.z_max === undefined) config.z_max = 300;

            // Set draft config and enable edit UI
            // Important: DEEP COPY to prevent reference leakage
            draftZoneConfig = JSON.parse(JSON.stringify(config));
            if (zoneModule && typeof zoneModule.normalizeZoneConfig === 'function') {
                draftZoneConfig = zoneModule.normalizeZoneConfig(draftZoneConfig, { allowZeroSpan: true, clampToBounds: true });
            }
            
            zoneEditorRawData.style.display = 'block';
            updateDraftCoordsText();

            // Enable drag in Plotly
            chartConfig.edits.shapePosition = true;
            layout.shapes = getChartShapes();
            layout.annotations = getChartAnnotations(); // Refresh annotations
            Plotly.react('chart', document.getElementById('chart').data, layout, chartConfig);
        }

        // Capture Plotly Drag Events
        document.getElementById('chart').on('plotly_relayout', function(eventData) {
            if (!isEditingZone) return;

            // Check if the event is a shape modification
            if (Object.keys(eventData).some(k => k.includes('shapes['))) {
                
                // Find the shape that is actively being edited (has dotted line)
                const shapes = document.getElementById('chart').layout.shapes;
                const activeShape = shapes.find(s => s.editable === true);

                if (activeShape) {
                    // Update only X/Y from drag, preserve Z
                    const rawDraft = {
                        x_min: Math.round(activeShape.x0),
                        x_max: Math.round(activeShape.x1),
                        y_min: Math.round(activeShape.y0),
                        y_max: Math.round(activeShape.y1),
                        z_min: draftZoneConfig.z_min,
                        z_max: draftZoneConfig.z_max
                    };
                    if (zoneModule && typeof zoneModule.normalizeZoneConfig === 'function') {
                        draftZoneConfig = zoneModule.normalizeZoneConfig(rawDraft, { allowZeroSpan: true, clampToBounds: true });
                    } else {
                        draftZoneConfig = rawDraft;
                    }
                    
                    updateDraftCoordsText();
                }
            }
        });
        
        // Manual Input Update
        function manualZoneUpdate() {
            if (!isEditingZone) return;

            const rawDraft = {
                x_min: parseInt(editXMin.value) || 0,
                x_max: parseInt(editXMax.value) || 0,
                y_min: parseInt(editYMin.value) || 0,
                y_max: parseInt(editYMax.value) || 0,
                z_min: parseInt(editZMin.value) || 0,
                z_max: parseInt(editZMax.value) || 0
            };
            if (zoneModule && typeof zoneModule.normalizeZoneConfig === 'function') {
                draftZoneConfig = zoneModule.normalizeZoneConfig(rawDraft, { allowZeroSpan: true, clampToBounds: true });
            } else {
                draftZoneConfig = rawDraft;
            }
             
            // Update the UI text (and potentially overlay text)
            updateDraftCoordsText();

            // Force Plotly update with new shapes based on manual input
            layout.shapes = getChartShapes();
            Plotly.react('chart', document.getElementById('chart').data, layout, chartConfig);
        }
        
        function updateDraftCoordsText() {
            if (draftZoneConfig) {
                // Only update inputs now, removed the popup text
                editXMin.value = draftZoneConfig.x_min;
                editXMax.value = draftZoneConfig.x_max;
                editYMin.value = draftZoneConfig.y_min;
                editYMax.value = draftZoneConfig.y_max;
                editZMin.value = draftZoneConfig.z_min;
                editZMax.value = draftZoneConfig.z_max;
            }
        }

        // Apply Button
        function applyZoneEdit() {
            if (!draftZoneConfig) return;

            const [category, area] = editingTarget.split(':');
            let areaPayload = null;

            if (zoneModule && typeof zoneModule.validateZoneConfig === 'function') {
                const validation = zoneModule.validateZoneConfig(draftZoneConfig, { allowZeroSpan: false });
                if (!validation.valid) {
                    const message = validation.errors && validation.errors.length > 0
                        ? validation.errors[0]
                        : 'Invalid zone coordinates';
                    if (window.SwitchStudioState) {
                        window.SwitchStudioState.setPacketStatus('error', message);
                        window.SwitchStudioState.showToast('error', message, 2800);
                    } else {
                        packetInfo.innerText = `Error: ${message}`;
                    }
                    return;
                }

                draftZoneConfig = validation.normalized;
                areaPayload = (typeof zoneModule.buildAreaPayload === 'function')
                    ? zoneModule.buildAreaPayload(area, draftZoneConfig)
                    : null;
            }

            if (!areaPayload) {
                const x_vals = [parseInt(draftZoneConfig.x_min), parseInt(draftZoneConfig.x_max)].sort((a,b)=>a-b);
                const y_vals = [parseInt(draftZoneConfig.y_min), parseInt(draftZoneConfig.y_max)].sort((a,b)=>a-b);
                const z_vals = [parseInt(draftZoneConfig.z_min), parseInt(draftZoneConfig.z_max)].sort((a,b)=>a-b);
                areaPayload = {};
                areaPayload[area] = {
                    width_min: x_vals[0],
                    width_max: x_vals[1],
                    depth_min: y_vals[0],
                    depth_max: y_vals[1],
                    height_min: z_vals[0],
                    height_max: z_vals[1]
                };
            }
             
            socket.emit('update_parameter', { param: category, value: areaPayload });

            endZoneEdit();
            if (window.SwitchStudioState) {
                window.SwitchStudioState.setPacketStatus('saved', 'Zone saved');
                window.SwitchStudioState.showToast('saved', 'Zone saved.', 1500);
            } else {
                packetInfo.innerText = "Zone Saved!";
            }
        }
        
        function deleteZone() {
            if (!confirm("Are you sure you want to delete this zone?")) return;
            
            const [category, area] = zoneEditorSelect.value.split(':');
            const areaPayload = {};
             
            // Always use width/depth keys for deletion
            areaPayload[area] = { 
                width_min: 0, width_max: 0, 
                depth_min: 0, depth_max: 0, 
                height_min: 0, height_max: 0 
            };
             
            socket.emit('update_parameter', { param: category, value: areaPayload });
            if (zoneModule && typeof zoneModule.appendCommandLog === 'function') {
                zoneModule.appendCommandLog(`Deleted zone ${area}`, 'info');
            }
            if (window.SwitchStudioState) {
                window.SwitchStudioState.setPacketStatus('saved', 'Zone deleted');
                window.SwitchStudioState.showToast('saved', 'Zone deleted.', 1500);
            } else {
                packetInfo.innerText = "Zone Deleted.";
            }
            endZoneEdit(); // Close editor
        }

        // Cancel Button - Restores view
        function cancelZoneEdit() {
            endZoneEdit();
            socket.emit('force_sync'); // Refresh from device to undo visual changes
        }
        
        function endZoneEdit() {
            isEditingZone = false;
            editingTarget = null;
            draftZoneConfig = null;
            //zoneEditorControls.style.display = 'none'; // REMOVED
            zoneEditorRawData.style.display = 'none';
            btnStartEdit.style.display = 'block'; // Show Start Button again

            // Reset chart editability
            chartConfig.edits.shapePosition = false;
            
            layout.shapes = getChartShapes();
            layout.annotations = getChartAnnotations(); // Reset annotations
            Plotly.react('chart', document.getElementById('chart').data, layout, chartConfig);
        }
    </script>
</body>
</html>



