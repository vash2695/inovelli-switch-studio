<!DOCTYPE html>
<html>
<head>
    <title>Inovelli Switch Studio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap');

        :root {
            --bg-base: #0f1117;
            --bg-elev-1: #131722;
            --bg-elev-2: #161921;
            --bg-elev-3: #1c1f2b;
            --panel-overlay: rgba(22, 25, 33, 0.96);
            --border-subtle: #2a2e3d;
            --border-strong: #343949;
            --text-primary: #e2e4ea;
            --text-secondary: #9ea5ba;
            --text-muted: #5c6178;
            --accent: #0dd4c0;
            --accent-strong: #0bbeb0;
            --accent-soft: rgba(13, 212, 192, 0.16);
            --success: #34d399;
            --warning: #fbbf24;
            --danger: #ff6f6f;
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 10px;
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 20px;
            --shadow-soft: 0 8px 20px rgba(0, 0, 0, 0.24);
            --shadow-panel: 0 12px 26px rgba(0, 0, 0, 0.3);
            --anim-fast: 0.16s ease;
            --anim-med: 0.24s ease;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: "DM Sans", "Segoe UI", sans-serif;
            background:
                radial-gradient(circle at 14% -10%, rgba(19, 76, 98, 0.24), transparent 42%),
                linear-gradient(180deg, #111521 0%, #0f121b 100%);
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            font-size: 13px;
            letter-spacing: 0;
        }

        *::-webkit-scrollbar {
            width: 5px;
            height: 5px;
        }
        *::-webkit-scrollbar-track {
            background: transparent;
        }
        *::-webkit-scrollbar-thumb {
            background: var(--border-subtle);
            border-radius: 999px;
        }

        .ui-card {
            background: var(--bg-elev-2);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-soft);
        }

        .ui-pill {
            border-radius: 999px;
            border: 1px solid var(--border-subtle);
            background: var(--bg-elev-3);
            color: var(--text-secondary);
            padding: var(--space-1) var(--space-3);
            font-size: 0.8em;
        }

        .ui-btn {
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-strong);
            background: var(--bg-elev-3);
            color: var(--text-primary);
            padding: 6px 10px;
            cursor: pointer;
            transition: border-color var(--anim-fast), background var(--anim-fast), color var(--anim-fast), transform var(--anim-fast);
        }

        .ui-btn:hover {
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .ui-btn:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }

        :focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        button,
        select,
        input,
        [role="tab"] {
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Header */
        .header {
            background: var(--bg-elev-2);
            padding: 0 12px;
            min-height: 52px;
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            gap: 14px;
        }
        .header-brand { display: flex; align-items: center; gap: 8px; min-width: 0; }
        .header-logo { height: 18px; width: auto; object-fit: contain; }
        .header-wordmark { height: 15px; width: auto; object-fit: contain; display: block; opacity: 0.98; }
        .studio-title { color: var(--text-primary); margin: 0; white-space: nowrap; letter-spacing: -0.01em; font-size: 0.92rem; font-weight: 600; }
        
        /* Header Controls Group */
        .header-controls { display: flex; align-items: center; gap: 8px; flex-grow: 1; justify-content: flex-start; min-width: 0; min-height: 38px; }
        .header-device-wrap { width: min(340px, 100%); min-width: 150px; }
        select#deviceSelect {
            background: var(--bg-elev-3);
            color: var(--text-primary);
            border: 1px solid var(--border-strong);
            padding: 6px 10px;
            font-size: 12px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            max-width: 300px;
            width: 100%;
            transition: border-color var(--anim-fast), box-shadow var(--anim-fast);
        }
        select#deviceSelect:hover,
        select#deviceSelect:focus-visible {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px var(--accent-soft);
        }
        select#deviceSelect.device-unselected {
            border-color: rgba(251, 191, 36, 0.75);
            background: linear-gradient(180deg, rgba(45, 40, 24, 0.42) 0%, rgba(32, 31, 27, 0.4) 100%), var(--bg-elev-3);
            box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.16);
        }
        select#deviceSelect.device-unselected:focus-visible,
        select#deviceSelect.device-unselected:hover {
            border-color: rgba(251, 191, 36, 0.92);
            box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.24);
        }
        .header-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
        }
        .status-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid var(--border-subtle);
            background: rgba(31, 36, 50, 0.9);
            color: var(--text-secondary);
            font-size: 0.7rem;
            white-space: nowrap;
        }
        .status-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: var(--success);
            box-shadow: 0 0 8px rgba(74, 197, 109, 0.75);
        }
        .status-chip.offline {
            color: #ffd6d6;
            border-color: rgba(255, 98, 98, 0.55);
            background: rgba(89, 41, 52, 0.58);
        }
        .status-chip.offline .status-dot {
            background: var(--danger);
            box-shadow: 0 0 8px rgba(255, 98, 98, 0.8);
        }
        .btn-force-sync {
            border-color: var(--accent);
            background: linear-gradient(135deg, var(--accent), #09b7aa);
            color: #061216;
            font-weight: 700;
            letter-spacing: 0.01em;
            padding: 5px 11px;
            font-size: 0.74rem;
        }
        .btn-force-sync:hover {
            filter: brightness(1.03);
            border-color: var(--accent);
            color: #041015;
        }
        
        #statusDiv { color: var(--text-secondary); }
        #packetInfo { color: var(--accent); font-weight: 700; }
        #timestamp { color: var(--warning); font-family: monospace; }
        #packetAge { color: var(--text-muted); font-size: 0.85em; font-family: monospace; min-width: 60px; text-align: left; }

        /* Tabs + Dirty State */
        .tab-bar {
            display: flex;
            align-items: stretch;
            gap: 6px;
            padding: 6px 10px;
            background: var(--bg-elev-2);
            border-bottom: 1px solid var(--border-subtle);
            flex-wrap: nowrap;
            overflow-x: auto;
            min-height: 52px;
        }
        .tab-btn {
            background: rgba(26, 31, 43, 0.92);
            color: #b4bfd4;
            border: 1px solid var(--border-subtle);
            border-bottom-color: var(--border-subtle);
            padding: 8px 12px;
            margin: 0;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.01em;
            transition: border-color var(--anim-fast), color var(--anim-fast), background var(--anim-fast), box-shadow var(--anim-fast), transform var(--anim-fast);
            border-radius: var(--radius-sm);
            white-space: nowrap;
            line-height: 1.1;
            min-height: 38px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            vertical-align: middle;
        }
        .tab-btn:hover {
            color: #ebfffc;
            background: rgba(13, 212, 192, 0.16);
            border-color: rgba(13, 212, 192, 0.45);
            transform: none;
        }
        .tab-btn:focus-visible {
            outline: none;
            box-shadow: 0 0 0 2px rgba(13, 212, 192, 0.3);
        }
        .tab-btn.active {
            background: linear-gradient(135deg, rgba(13, 212, 192, 0.36), rgba(13, 212, 192, 0.2));
            color: #f2fffe;
            border-color: rgba(13, 212, 192, 0.72);
            font-weight: 600;
            box-shadow: 0 0 0 1px rgba(13, 212, 192, 0.26) inset;
            transform: none;
        }

        .dirty-bar {
            display: none;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            background: var(--bg-elev-2);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-sm);
            padding: 10px 12px;
            color: var(--text-muted);
            position: static;
            margin-top: 10px;
            z-index: 18;
            box-shadow: 0 -8px 18px rgba(0, 0, 0, 0.18);
        }
        .dirty-bar.dirty-active {
            display: flex;
            color: #ffd59c;
            border-color: var(--warning);
            position: fixed;
            right: 12px;
            bottom: calc(10px + env(safe-area-inset-bottom, 0px));
            width: min(372px, calc(100vw - 24px));
            margin-top: 0;
            z-index: 60;
        }
        .app-container.focus-config .dirty-bar.dirty-active {
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            width: min(920px, calc(100vw - 20px));
        }
        body.dirty-bar-visible .main-content {
            padding-bottom: calc(84px + env(safe-area-inset-bottom, 0px));
        }
        body.dirty-bar-visible .sidebar {
            padding-bottom: calc(94px + env(safe-area-inset-bottom, 0px));
        }
        .dirty-actions { display: flex; gap: 8px; }
        .dirty-btn {
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-strong);
            background: var(--bg-elev-3);
            color: var(--text-primary);
            padding: 7px 10px;
            cursor: pointer;
            font-size: 0.76rem;
            transition: border-color var(--anim-fast), background var(--anim-fast), color var(--anim-fast);
        }
        .dirty-btn:disabled { opacity: 0.45; cursor: not-allowed; }
        .dirty-btn:not(:disabled):hover { border-color: var(--accent); color: #fff; background: rgba(13, 212, 192, 0.12); }
        .dirty-btn:not(:disabled):active { transform: translateY(1px); }
        .dirty-btn:focus-visible {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(13, 212, 192, 0.24);
        }
        .dirty-btn.apply-btn { border-color: var(--success); }
        .dirty-btn.apply-btn:not(:disabled):hover { background: linear-gradient(135deg, var(--accent), #0bbeb0); color: #061216; border-color: transparent; }
        .dirty-btn.apply-btn:not(:disabled) {
            background: linear-gradient(135deg, rgba(13, 212, 192, 0.18), rgba(13, 212, 192, 0.1));
            color: var(--accent);
        }

        .zones-sidebar-tabs {
            display: flex;
            align-items: center;
            gap: 0;
            padding: 0 10px;
            border-bottom: 1px solid var(--border-subtle);
            background: var(--bg-elev-2);
            min-height: 44px;
        }
        .zones-sidebar-tab {
            flex: 1;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.7rem;
            font-weight: 500;
            letter-spacing: 0.01em;
            padding: 11px 8px 9px;
            cursor: pointer;
            transition: border-color var(--anim-fast), background var(--anim-fast), color var(--anim-fast);
            border-bottom: 2px solid transparent;
        }
        .zones-sidebar-tab:hover {
            color: #dce8f2;
            background: rgba(255, 255, 255, 0.02);
        }
        .zones-sidebar-tab:focus-visible {
            outline: none;
            box-shadow: inset 0 -2px 0 var(--accent), 0 0 0 2px rgba(13, 212, 192, 0.24);
        }
        .zones-sidebar-tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
            background: rgba(255, 255, 255, 0.01);
            font-weight: 600;
        }
        .zones-pane {
            display: none;
            flex-direction: column;
            gap: 10px;
            padding: 12px 12px 0;
        }
        .zones-pane.is-active {
            display: flex;
        }
        .live-sensor-card {
            background: rgba(18, 23, 34, 0.8);
            border-color: rgba(13, 212, 192, 0.26);
        }
        .live-sensor-card .config-title {
            color: var(--accent);
            border-bottom-color: rgba(22, 215, 203, 0.34);
        }
        .panel-lede {
            margin-bottom: 10px;
            font-size: 0.76rem;
            color: #8d97ad;
            line-height: 1.45;
        }
        .config-tab-shell {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 12px 12px 0;
        }
        .config-tab-shell .panel-section + .panel-section {
            margin-top: 0;
        }
        .config-tab-shell .panel-section {
            background: linear-gradient(180deg, rgba(30, 39, 56, 0.95) 0%, rgba(25, 33, 48, 0.97) 100%);
        }
        .conditional-section[hidden] {
            display: none !important;
        }

        .zones-live-strip {
            display: grid;
            grid-template-columns: minmax(0, 1fr) auto;
            align-items: center;
            gap: 8px 10px;
            padding: 7px 10px;
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            background: rgba(18, 23, 34, 0.88);
        }
        .zones-live-status {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            min-width: 0;
            overflow: hidden;
            padding-bottom: 1px;
        }
        .zones-status-item {
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 0 1 auto;
            min-width: 0;
        }
        .zones-status-item > span {
            overflow: hidden;
            text-overflow: ellipsis;
            display: block;
        }
        .zones-status-item.zones-last-packet {
            max-width: 100%;
            flex: 1 1 auto;
            min-width: 0;
        }
        .zones-pill-row {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .zone-live-pill {
            display: inline-flex;
            align-items: center;
            gap: 7px;
            padding: 4px 9px;
            border: 1px solid var(--border-subtle);
            border-radius: 999px;
            background: rgba(28, 33, 46, 0.96);
            color: var(--text-secondary);
            transition: border-color var(--anim-fast), background var(--anim-fast), color var(--anim-fast);
        }
        .zone-live-pill-active {
            border-color: rgba(74, 197, 109, 0.55);
            background: rgba(40, 92, 64, 0.34);
            color: #e9fff0;
        }
        .zone-live-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-muted);
            box-shadow: 0 0 6px rgba(127, 139, 163, 0.6);
        }
        .zone-live-pill-active .zone-live-dot {
            background: var(--success);
            box-shadow: 0 0 8px rgba(74, 197, 109, 0.8);
        }
        .zone-live-label {
            font-size: 0.72rem;
            letter-spacing: 0.01em;
            color: inherit;
        }
        .zone-live-state {
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 0.03em;
            color: inherit;
        }
        .zones-live-meta {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
            flex-wrap: nowrap;
            min-width: max-content;
        }
        .zones-meta-item {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-sm);
            background: rgba(26, 31, 43, 0.92);
            color: var(--text-secondary);
            padding: 4px 8px;
            font-size: 0.7rem;
            white-space: nowrap;
        }
        .zones-meta-item strong {
            color: #f3c26a;
            font-weight: 700;
        }
        .zones-report-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-sm);
            background: rgba(26, 31, 43, 0.92);
            color: var(--text-secondary);
            padding: 4px 8px;
            font-size: 0.7rem;
            white-space: nowrap;
            cursor: pointer;
        }
        .zones-report-toggle input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 34px;
            height: 18px;
            border-radius: 999px;
            border: 1px solid var(--border-strong);
            background: var(--bg-elev-3);
            margin: 0;
            cursor: pointer;
            position: relative;
            transition: background var(--anim-fast), border-color var(--anim-fast);
        }
        .zones-report-toggle input[type="checkbox"]::before {
            content: '';
            position: absolute;
            top: 1px;
            left: 1px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #f5f7fa;
            transition: transform var(--anim-fast);
            box-shadow: 0 0 6px rgba(0, 0, 0, 0.24);
        }
        .zones-report-toggle input[type="checkbox"]:checked {
            background: rgba(13, 212, 192, 0.95);
            border-color: rgba(13, 212, 192, 0.95);
        }
        .zones-report-toggle input[type="checkbox"]:checked::before {
            transform: translateX(16px);
        }
        .zones-report-toggle input[type="checkbox"]:focus-visible {
            outline: none;
            box-shadow: 0 0 0 2px rgba(13, 212, 192, 0.3);
        }
        .zones-report-state {
            border-radius: 999px;
            border: 1px solid var(--border-subtle);
            padding: 2px 8px;
            font-weight: 700;
            font-size: 0.73rem;
            letter-spacing: 0.02em;
        }
        .zones-report-on {
            color: #062315;
            background: var(--success);
            border-color: var(--success);
        }
        .zones-report-off {
            color: var(--text-secondary);
            background: rgba(43, 55, 78, 0.92);
            border-color: #50607e;
        }

        /* Toasts */
        #toastContainer { position: fixed; right: 18px; bottom: 18px; z-index: 2500; display: flex; flex-direction: column; gap: 8px; pointer-events: none; max-width: min(420px, 85vw); }
        .studio-toast {
            background: rgba(31, 40, 57, 0.98);
            border: 1px solid var(--border-strong);
            color: var(--text-primary);
            border-radius: var(--radius-md);
            padding: 10px 12px;
            box-shadow: var(--shadow-soft);
            font-size: 0.86em;
            transition: opacity var(--anim-med), transform var(--anim-med);
        }
        .studio-toast.fade-out { opacity: 0; transform: translateY(6px); }
        .studio-toast-saved { border-color: var(--success); }
        .studio-toast-syncing { border-color: var(--accent); }
        .studio-toast-error { border-color: var(--danger); }

        /* Main Layout Grid */
        .app-container { display: grid; grid-template-columns: minmax(0, 1fr) 390px; flex-grow: 1; overflow: hidden; transition: var(--anim-med); }
        .main-content { display: flex; flex-direction: column; padding: 8px 6px 10px; overflow-y: auto; position: relative; gap: 8px; }
        .sidebar {
            background: var(--bg-elev-2);
            border-left: 1px solid var(--border-subtle);
            padding: 0;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0;
            transition: opacity var(--anim-med);
        }
        .app-container.focus-config { display: block; overflow-y: auto; }
        .app-container.focus-config .main-content { padding: 10px 14px 2px; min-height: auto; }
        .app-container.focus-config .sidebar { border-left: none; background: transparent; max-width: 1200px; margin: 0 auto; padding: 8px 14px 24px; }
        .app-container.focus-config .sidebar .panel-section,
        .app-container.focus-config .sidebar .config-group {
            background: #232f40;
            border-color: var(--border-strong);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        /* Chart & Table */
        #chartContainer {
            border: 1px solid var(--border-subtle);
            background: #0e121c;
            border-radius: var(--radius-md);
            overflow: hidden;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
        }
        #chartContainer .chart-panel-title {
            display: none;
        }
        #chart {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            min-height: 0;
            border-radius: var(--radius-lg);
            border: 1px solid rgba(34, 42, 58, 0.9);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
        }
        .chart-canvas-wrap {
            position: relative;
            width: 100%;
            aspect-ratio: 13 / 7;
        }
        
        .table-container {
            background: #121722;
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            overflow-x: auto;
            margin-top: -2px;
        }
        table { width: 100%; border-collapse: collapse; text-align: center; min-width: 500px; }
        th { background: transparent; color: var(--text-muted); padding: 6px 10px; font-weight: 500; border-bottom: 1px solid var(--border-subtle); }
        td { padding: 6px 10px; border-bottom: 1px solid rgba(42, 46, 61, 0.6); }
        .no-data { padding: 15px; font-style: italic; color: var(--text-muted); }
        .target-table th { font-size: 0.62rem; text-transform: uppercase; letter-spacing: 0.08em; }
        .target-table td { font-size: 0.72rem; color: #d6dbe5; }
        .target-id-cell { text-align: left; }
        .target-id-tag {
            display: inline-flex;
            align-items: center;
            justify-content: flex-start;
            gap: 6px;
            color: #cfd7e5;
            font-weight: 500;
            font-size: 0.68rem;
        }
        .target-id-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 0 7px currentColor;
        }
        .target-id-tag.target-primary .target-id-dot {
            color: var(--accent);
            background: var(--accent);
        }
        .target-id-tag.target-secondary .target-id-dot {
            color: #60a5fa;
            background: #60a5fa;
        }
        .target-num {
            text-align: right;
            font-variant-numeric: tabular-nums;
            color: #c6d4e8;
        }
        .doppler-cell {
            text-align: left;
        }
        .doppler-badge {
            display: inline-flex;
            align-items: center;
            border-radius: var(--radius-sm);
            padding: 2px 7px;
            font-size: 0.68rem;
            font-weight: 700;
            letter-spacing: 0.01em;
            border: 1px solid transparent;
        }
        .doppler-stationary {
            background: rgba(22, 215, 203, 0.14);
            border-color: rgba(22, 215, 203, 0.38);
            color: #9ef8ef;
        }
        .doppler-moving {
            background: rgba(240, 170, 82, 0.14);
            border-color: rgba(240, 170, 82, 0.44);
            color: #ffd8a4;
        }
        .doppler-approaching {
            background: rgba(74, 197, 109, 0.15);
            border-color: rgba(74, 197, 109, 0.45);
            color: #c7ffd6;
        }

        /* Panel Sections */
        .config-content { padding: 10px; }
        .panel-section {
            background: var(--bg-elev-1);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
        }
        .panel-section + .panel-section {
            margin-top: 10px;
        }
        .panel-section-title {
            font-weight: 600;
            color: #8c98af;
            padding: 9px 10px;
            font-size: 0.64rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            border-bottom: 1px solid var(--border-subtle);
        }
        .panel-section .config-content {
            padding: 10px;
        }

        /* Radar Container needs flex to handle Plotly resizing */
        #chartContainer .config-content {
            display: block;
            padding: 0;
            overflow: hidden;
            position: relative;
        }

        /* Config Groups */
        .config-group { background: var(--bg-elev-1); padding: 10px; border-radius: var(--radius-md); border: 1px solid var(--border-subtle); }
        .config-title { font-weight: 600; color: var(--accent); margin-bottom: 8px; border-bottom: 1px solid var(--border-subtle); padding-bottom: 5px; font-size: 0.74rem; text-transform: uppercase; letter-spacing: 0.06em; }

        /* Inputs */
        .input-row {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(138px, 188px);
            gap: 8px;
            align-items: center;
            margin-bottom: 7px;
            font-size: 0.78rem;
        }
        .input-row label { color: #a3acc1; min-width: 0; line-height: 1.2; overflow-wrap: anywhere; }
        input[type="number"] {
            width: 122px;
            background: var(--bg-elev-3);
            color: var(--text-primary);
            border: 1px solid var(--border-strong);
            border-radius: var(--radius-sm);
            padding: 5px 6px;
            text-align: right;
            transition: border-color var(--anim-fast), box-shadow var(--anim-fast);
        }
        .control-select,
        .full-width-select {
            background: var(--bg-elev-3);
            border: 1px solid var(--border-strong);
            color: var(--text-primary);
            border-radius: var(--radius-sm);
            transition: border-color var(--anim-fast), box-shadow var(--anim-fast);
        }
        .control-select { width: 100%; margin-top: 1px; padding: 5px 7px; font-size: 0.73rem; }
        .full-width-select { width: 100%; max-width: 100%; box-sizing: border-box; margin-top: 1px; padding: 5px 7px; font-size: 0.73rem; }
        .control-select:hover,
        .control-select:focus-visible,
        .full-width-select:hover,
        .full-width-select:focus-visible,
        input[type="number"]:hover,
        input[type="number"]:focus-visible {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px var(--accent-soft);
        }
        
        /* Settings Checkboxes */
        .input-row input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 34px;
            height: 18px;
            border-radius: 999px;
            border: 1px solid var(--border-strong);
            background: var(--bg-elev-3);
            cursor: pointer;
            position: relative;
            transition: border-color var(--anim-fast), background var(--anim-fast);
            margin: 0;
            justify-self: end;
        }
        .input-row input[type="checkbox"]::before {
            content: '';
            position: absolute;
            top: 1px;
            left: 1px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #f2f6fb;
            transition: transform var(--anim-fast);
            box-shadow: 0 0 6px rgba(0, 0, 0, 0.24);
        }
        .input-row input[type="checkbox"]:checked {
            background: rgba(13, 212, 192, 0.95);
            border-color: rgba(13, 212, 192, 0.95);
        }
        .input-row input[type="checkbox"]:checked::before {
            transform: translateX(16px);
        }
        .input-row input[type="checkbox"]:focus-visible {
            outline: none;
            box-shadow: 0 0 0 2px rgba(13, 212, 192, 0.28);
        }

        /* Grid for Raw Zone Data */
        .zone-data-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px; }
        .zone-input-group { display: flex; flex-direction: column; gap: 2px; }
        .zone-input-group label { font-size: 0.75em; color: var(--text-muted); }
        .zone-input-group input { width: 100%; box-sizing: border-box; font-family: monospace; color: var(--accent); font-weight: bold;}

        /* Live Sensor Badges */
        .sensor-row { display: flex; justify-content: space-between; background: #151a25; border: 1px solid #2a3040; padding: 7px 9px; border-radius: var(--radius-sm); margin-bottom: 6px; font-size: 0.73rem; }
        .sensor-val { font-weight: bold; color: #f3f7fe; }
        .badge-detected { color: var(--success); font-weight: bold; }
        .badge-clear { color: var(--text-muted); font-style: italic; }

        /* Small badges for Zone Status */
        .zone-badge { font-size: 0.85em; padding: 2px 6px; border-radius: 3px; background: var(--bg-elev-3); color: var(--text-muted); border: 1px solid var(--border-subtle); }
        .zone-active { background: #2e7d32; color: #f4fff7; border-color: #3e9f45; }
        .zone-status-inline .config-content {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 8px;
            padding: 8px;
        }
        .zone-status-inline .sensor-row {
            margin-bottom: 0;
            min-height: 36px;
        }

        /* Buttons */
        .cmd-btn {
            background: var(--bg-elev-3);
            color: var(--text-primary);
            border: 1px solid var(--border-strong);
            padding: 7px 10px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: border-color var(--anim-fast), background var(--anim-fast), color var(--anim-fast);
            font-size: 0.72rem;
            white-space: nowrap;
        }
        .cmd-btn:hover {
            border-color: var(--accent);
            background: rgba(13, 212, 192, 0.16);
            color: #dffffb;
        }
        .cmd-btn:active {
            transform: translateY(1px);
        }
        .cmd-btn:focus-visible {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(13, 212, 192, 0.22);
        }
        .cmd-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            filter: grayscale(0.15);
        }
        .cmd-btn:disabled:hover {
            border-color: var(--border-strong);
            background: var(--bg-elev-3);
            color: var(--text-primary);
        }
        .btn-danger { border-color: #d86e6e; }
        .btn-danger:hover { background: rgba(255, 111, 111, 0.17); color: #ffdada; border-color: #ff7b7b; }
        .btn-full { width: 100%; margin-bottom: 5px; }

        .command-log {
            background: #161d2a;
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-sm);
            padding: 8px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 0.82em;
            font-family: Consolas, 'Courier New', monospace;
        }
        .command-log-empty { color: #77839b; font-style: italic; }
        .command-log-entry { margin-bottom: 5px; }
        .command-log-entry:last-child { margin-bottom: 0; }
        .command-log-entry.log-syncing { color: var(--accent); }
        .command-log-entry.log-saved { color: var(--success); }
        .command-log-entry.log-error { color: var(--danger); }
        .command-log-entry.log-info { color: #bbb; }

        .schema-fields-shell {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .schema-loading-note {
            font-size: 0.74rem;
            color: #8d96aa;
        }
        .schema-section-block {
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-sm);
            background: rgba(20, 25, 36, 0.9);
            padding: 9px 10px 8px;
        }
        .schema-section-title {
            font-size: 0.64rem;
            color: #8e98ac;
            margin: 0 0 8px 0;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            border-bottom: 1px solid rgba(141, 185, 203, 0.22);
            padding-bottom: 5px;
        }
        .schema-description {
            font-size: 0.72rem;
            color: #7f8aa0;
            margin-top: -4px;
            margin-bottom: 8px;
            line-height: 1.35;
        }
        .schema-empty-note {
            font-size: 0.88em;
            color: #96a7c0;
            padding: 2px 0;
        }
        .schema-readonly-value {
            font-family: Consolas, "Courier New", monospace;
            color: var(--accent);
            font-weight: 700;
            justify-self: end;
        }
        .schema-composite-block { border: 1px solid var(--border-subtle); border-radius: var(--radius-sm); padding: 8px; margin-bottom: 8px; background: #1b2433; }
        .schema-composite-title { color: var(--accent); font-weight: 600; margin-bottom: 6px; font-size: 0.86em; }
        .schema-composite-note { color: var(--text-muted); font-size: 0.78em; margin-top: 4px; }
        .led-color-select { width: 176px; }
        .slider-control { display: flex; align-items: center; justify-content: flex-end; gap: 8px; min-width: 190px; }
        .slider-control input[type="range"] { width: 128px; accent-color: var(--accent); }
        .slider-value { min-width: 42px; text-align: right; color: #9edee8; font-family: Consolas, 'Courier New', monospace; font-size: 0.8em; }

        #zoneStatus { display: none; position: fixed; top: 20px; right: 20px; background: var(--bg-elev-3); color: var(--text-primary); padding: 15px 20px; border-radius: var(--radius-md); z-index: 1000; border: 1px solid var(--border-strong); box-shadow: var(--shadow-panel); }

        /* Non-mmWave Overlay Warning */
        #nonMmwaveWarning {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 98, 98, 0.9);
            color: #fff5f5;
            padding: 20px 30px;
            border-radius: var(--radius-md);
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 20;
            border: 1px solid rgba(255, 210, 210, 0.5);
        }

        input[type="checkbox"] {
            accent-color: var(--accent);
        }

        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }

        @media (max-width: 1180px) {
            .zones-live-status {
                gap: 6px;
            }
            .zones-status-item {
                max-width: 100%;
            }
            .zones-meta-item {
                font-size: 0.66rem;
                padding: 3px 7px;
            }
            .zones-live-meta {
                gap: 6px;
            }
        }

        /* Responsive Design: Mobile Layout Adjustments */
        @media (max-width: 900px) {
            body {
                height: auto;
                min-height: 100dvh;
                overflow-y: auto;
            }
            .header {
                position: sticky;
                top: 0;
                z-index: 18;
                padding: 7px 9px;
                flex-wrap: wrap;
                gap: 7px;
            }
            .header-brand {
                display: none;
            }
            .header-controls {
                width: 100%;
                display: grid;
                grid-template-columns: minmax(0, 1fr) auto;
                align-items: center;
                gap: 8px;
            }
            .header-device-wrap {
                min-width: 0;
                width: 100%;
            }
            select#deviceSelect {
                max-width: unset;
                width: 100%;
                margin-right: 0;
            }
            .header-right {
                margin-left: 0;
                width: auto;
                justify-content: flex-end;
                flex-wrap: nowrap;
            }
            .status-chip {
                display: none;
            }
            .btn-force-sync {
                width: auto;
                justify-content: center;
                padding: 6px 10px;
                font-size: 0.72rem;
                white-space: nowrap;
            }

            .tab-bar {
                gap: 6px;
                padding: 7px 8px;
                flex-wrap: wrap;
                overflow-x: visible;
            }
            .tab-btn {
                padding: 8px 10px;
                font-size: 0.73rem;
                min-width: 116px;
                flex: 1 1 auto;
                text-align: center;
            }

            .app-container {
                display: block;
                overflow: visible;
                -webkit-overflow-scrolling: touch;
            }
            .main-content {
                overflow: visible;
                height: auto;
                flex: none;
                padding: 8px 6px 10px;
                gap: 7px;
            }
            .sidebar {
                border-left: none;
                border-top: 1px solid var(--border-subtle);
                height: auto;
                overflow: visible;
                flex: none;
                padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
            }

            #chart { border-radius: var(--radius-md); }

            .zones-live-strip {
                padding: 7px 8px;
                grid-template-columns: minmax(0, 1fr);
                gap: 7px;
            }
            .zones-live-meta {
                width: 100%;
                justify-content: flex-start;
                order: 1;
                gap: 6px;
                min-width: 0;
                flex-wrap: wrap;
            }
            .zones-live-status {
                width: 100%;
                order: 2;
                gap: 6px;
                overflow: visible;
                padding-bottom: 1px;
            }
            .zones-status-item {
                max-width: 100%;
                flex: 1 1 45%;
            }
            .zones-status-item.zones-last-packet {
                flex: 1 1 100%;
            }
            .zones-meta-item,
            .zones-report-toggle {
                font-size: 0.68rem;
                padding: 3px 7px;
            }

            .table-container {
                width: 100%;
                margin-bottom: 10px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            table {
                min-width: 430px;
                font-size: 0.72rem;
            }
            th,
            td {
                padding: 5px 6px;
            }
            .target-table th {
                font-size: 0.55rem;
                letter-spacing: 0.06em;
            }
            .target-table td {
                font-size: 0.66rem;
            }
            .target-id-tag,
            .doppler-badge {
                font-size: 0.62rem;
            }

            .zones-sidebar-tabs {
                overflow-x: auto;
                padding: 5px;
                gap: 6px;
            }
            .zones-sidebar-tab {
                min-width: 110px;
                flex: 0 0 auto;
            }
            .config-tab-shell {
                padding: 10px 10px 0;
                gap: 8px;
            }

            .zone-status-inline .config-content {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .dirty-bar {
                position: static;
                margin-top: 10px;
                padding: 9px 10px;
                box-shadow: 0 -6px 14px rgba(0, 0, 0, 0.18);
            }
            .dirty-bar.dirty-active {
                left: 8px;
                right: 8px;
                width: auto;
                bottom: calc(8px + env(safe-area-inset-bottom, 0px));
                transform: none;
            }
            body.dirty-bar-visible .sidebar {
                padding-bottom: calc(106px + env(safe-area-inset-bottom, 0px));
            }
            .dirty-actions {
                width: auto;
                margin-left: auto;
                justify-content: flex-end;
            }
            .dirty-btn {
                min-width: 84px;
            }

            .input-row {
                grid-template-columns: minmax(0, 1fr);
                gap: 6px;
            }
            .control-select,
            .full-width-select {
                width: 100%;
            }
            #toastContainer {
                right: 10px;
                bottom: calc(10px + env(safe-area-inset-bottom, 0px));
                max-width: min(360px, 90vw);
            }
        }

        @media (max-width: 640px) {
            .header {
                padding: 6px 8px;
            }
            .header-controls {
                gap: 6px;
            }
            select#deviceSelect {
                font-size: 11px;
                padding: 6px 8px;
            }
            .btn-force-sync {
                padding: 6px 9px;
                font-size: 0.69rem;
            }

            .tab-btn {
                padding: 7px 8px;
                font-size: 0.68rem;
                min-width: 0;
                flex: 1 1 calc(50% - 3px);
            }

            .zones-live-meta {
                justify-content: flex-start;
                flex-wrap: wrap;
            }
            .zones-status-item {
                flex-basis: 100%;
            }
            .zone-status-inline .config-content {
                grid-template-columns: 1fr;
            }

            table {
                min-width: 400px;
            }
            .target-table th {
                font-size: 0.53rem;
            }
            .target-table td {
                font-size: 0.63rem;
            }

            .dirty-bar {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            .dirty-actions {
                width: 100%;
                margin-left: 0;
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }
            .dirty-btn {
                width: 100%;
                min-width: 0;
            }

            .zones-sidebar-tab {
                min-width: 102px;
                padding: 7px 9px;
                font-size: 0.65rem;
            }
            .config-tab-shell {
                padding: 8px 8px 0;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-brand">
            <img class="header-logo" src="{{ ingress_path }}/static/logo.png" alt="Switch Studio icon">
            <img class="header-wordmark" src="{{ ingress_path }}/static/brand_name.svg" alt="Inovelli">
            <h2 class="studio-title">Switch Studio</h2>
        </div>
        <div class="header-controls">
            <div class="header-device-wrap">
                <select id="deviceSelect"><option value="" disabled selected>Loading devices...</option></select>
            </div>
            <div class="header-right">
                <span class="status-chip" id="connectionChip"><span class="status-dot" id="connectionDot"></span><span id="connectionText">Connecting...</span></span>
                <button class="cmd-btn btn-force-sync" id="btnForceSync" onclick="handleForceSyncClick()">Force Sync</button>
            </div>
        </div>
    </div>

    <div class="tab-bar" id="tabBar" role="tablist" aria-label="Inovelli Switch Studio tabs">
        <button class="tab-btn" type="button" data-tab-target="zones" role="tab" aria-selected="true">Presence & Zones</button>
        <button class="tab-btn" type="button" data-tab-target="load" role="tab" aria-selected="false">Load & Dimming</button>
        <button class="tab-btn" type="button" data-tab-target="led" role="tab" aria-selected="false">LED & Notifications</button>
        <button class="tab-btn" type="button" data-tab-target="buttons" role="tab" aria-selected="false">Buttons & Scenes</button>
        <button class="tab-btn" type="button" data-tab-target="power" role="tab" aria-selected="false">Power & Device</button>
        <button class="tab-btn" type="button" data-tab-target="advanced" role="tab" aria-selected="false">Advanced</button>
    </div>

    <div id="zoneStatus"></div>
    <div id="toastContainer"></div>

    <div class="app-container focus-zones" id="appContainer">
        <div class="main-content">
            <div id="nonMmwaveWarning" data-tab-panels="zones,load,led,buttons,power,advanced">WARNING: Standard Switch Detected<br><span style="font-size: 0.8em; font-weight: normal;">This device does not have mmWave hardware.</span></div>

            <div class="zones-live-strip" data-tab-panels="zones">
                <div class="zones-live-status">
                    <span class="zones-meta-item zones-status-item"><span id="statusDiv">Waiting for connection...</span></span>
                    <span class="zones-meta-item zones-status-item"><span id="packetInfo">Awaiting data...</span></span>
                    <span class="zones-meta-item zones-status-item zones-last-packet">Last packet: <span id="timestamp">--:--:--</span> <span id="packetAge"></span></span>
                </div>
                <div class="zones-live-meta">
                    <span class="zones-meta-item">Illuminance <strong id="stripIlluminanceVal">-- lx</strong></span>
                    <label class="zones-report-toggle" for="targetReportToggle">
                        <span>Target Reporting</span>
                        <input type="checkbox" id="targetReportToggle">
                        <span id="stripTargetReportState" class="zones-report-state zones-report-off">OFF</span>
                    </label>
                </div>
            </div>
            
            <section id="chartContainer" data-tab-panels="zones">
                <div class="chart-panel-title">Live Radar Map</div>
                <div class="config-content">
                    <div class="chart-canvas-wrap">
                        <div id="chart"></div>
                    </div>
                </div>
            </section>

            <section class="panel-section zone-status-inline" id="zoneStatusSection" data-tab-panels="zones">
                <div class="panel-section-title">Zone Status</div>
                <div class="config-content">
                    <div class="sensor-row">
                        <span style="color: #ccc;">Area 1:</span>
                        <span id="area1Val" class="zone-badge">CLEAR</span>
                    </div>
                    <div class="sensor-row">
                        <span style="color: #ccc;">Area 2:</span>
                        <span id="area2Val" class="zone-badge">CLEAR</span>
                    </div>
                    <div class="sensor-row">
                        <span style="color: #ccc;">Area 3:</span>
                        <span id="area3Val" class="zone-badge">CLEAR</span>
                    </div>
                    <div class="sensor-row">
                        <span style="color: #ccc;">Area 4:</span>
                        <span id="area4Val" class="zone-badge">CLEAR</span>
                    </div>
                </div>
            </section>

            <div class="table-container" data-tab-panels="zones">
                <table class="target-table">
                    <thead>
                        <tr>
                            <th>Target</th>
                            <th>X (Width)</th>
                            <th>Y (Depth)</th>
                            <th>Z (Height)</th>
                            <th>Action (Doppler)</th>
                        </tr>
                    </thead>
                    <tbody id="dataTableBody">
                        <tr><td colspan="5" class="no-data">No targets detected</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="sidebar" id="configSidebar">
            <div class="zones-sidebar-tabs" id="zonesSidebarTabs" data-tab-panels="zones" role="tablist" aria-label="Presence and zones sidebar views">
                <button class="zones-sidebar-tab active" type="button" id="zonesPaneTabControls" role="tab" data-zones-pane-target="controls" aria-selected="true" aria-controls="zonesPaneControls">Controls & Zones</button>
                <button class="zones-sidebar-tab" type="button" id="zonesPaneTabConfig" role="tab" data-zones-pane-target="config" aria-selected="false" aria-controls="zonesPaneConfig">Configuration</button>
                <button class="zones-sidebar-tab" type="button" id="zonesPaneTabView" role="tab" data-zones-pane-target="view" aria-selected="false" aria-controls="zonesPaneView">View</button>
            </div>

            <div class="zones-pane is-active" id="zonesPaneControls" role="tabpanel" aria-labelledby="zonesPaneTabControls" data-zones-pane="controls" data-tab-panels="zones">
            <div class="config-group live-sensor-card">
                <div class="config-title">Live Sensors</div>
                <div class="sensor-row">
                    <span style="color: #ccc;">Area 1 (Primary):</span>
                    <span id="occupancyVal" class="sensor-val badge-clear">Waiting...</span>
                </div>
                <div class="sensor-row">
                    <span style="color: #ccc;">Illuminance:</span>
                    <span id="illuminanceVal" class="sensor-val">-- lx</span>
                </div>
            </div>

            <section class="panel-section" data-tab-panels="zones">
                <div class="panel-section-title">Zone Editor</div>
                <div class="config-content">
                    <div style="margin-bottom: 10px; font-size: 0.9em; color: #ccc;">Select a zone to view, draw, or edit.</div>
                    
                    <div class="input-row">
                        <label>Target Zone:</label>
                        <select class="control-select" id="zoneEditorSelect">
                            <option value="mmwave_detection_areas:area1">Detection Area 1 (Primary - Blue)</option>
                            <option value="mmwave_detection_areas:area2">Detection Area 2 (Green)</option>
                            <option value="mmwave_detection_areas:area3">Detection Area 3 (Green)</option>
                            <option value="mmwave_detection_areas:area4">Detection Area 4 (Green)</option>
                            <option value="" disabled>--- Interference Areas ---</option>
                            <option value="mmwave_interference_areas:area1">Interference Area 1 (Red)</option>
                            <option value="mmwave_interference_areas:area2">Interference Area 2 (Red)</option>
                            <option value="mmwave_interference_areas:area3">Interference Area 3 (Red)</option>
                            <option value="mmwave_interference_areas:area4">Interference Area 4 (Red)</option>
                            <option value="" disabled>--- Stay Areas ---</option>
                            <option value="mmwave_stay_areas:area1">Stay Area 1 (Orange)</option>
                            <option value="mmwave_stay_areas:area2">Stay Area 2 (Orange)</option>
                            <option value="mmwave_stay_areas:area3">Stay Area 3 (Orange)</option>
                            <option value="mmwave_stay_areas:area4">Stay Area 4 (Orange)</option>
                        </select>
                    </div>

                    <div id="zoneEditorRawData" style="display: none; border: 1px solid #444; padding: 10px; border-radius: 4px; background: #222; margin-bottom: 10px;">
                        <div style="font-size: 0.85em; font-weight: bold; margin-bottom: 5px; color: #00bcd4;">Raw Zone Data (cm)</div>
                        <div class="zone-data-grid">
                            <div class="zone-input-group"><label>X Min (Width)</label><input type="number" id="editXMin" onchange="manualZoneUpdate()"></div>
                            <div class="zone-input-group"><label>X Max (Width)</label><input type="number" id="editXMax" onchange="manualZoneUpdate()"></div>
                            <div class="zone-input-group"><label>Y Min (Depth)</label><input type="number" id="editYMin" onchange="manualZoneUpdate()"></div>
                            <div class="zone-input-group"><label>Y Max (Depth)</label><input type="number" id="editYMax" onchange="manualZoneUpdate()"></div>
                            <div class="zone-input-group"><label>Z Min (Height)</label><input type="number" id="editZMin" onchange="manualZoneUpdate()"></div>
                            <div class="zone-input-group"><label>Z Max (Height)</label><input type="number" id="editZMax" onchange="manualZoneUpdate()"></div>
                        </div>
                        <div style="display:flex; gap: 5px;">
                            <button class="cmd-btn btn-danger" style="flex:1;" onclick="cancelZoneEdit()">Stop Editing</button>
                            <button class="cmd-btn" style="background: #00bcd4; color: #1a1a1a; flex:1;" onclick="applyZoneEdit()">Apply Changes</button>
                        </div>
                    </div>

                    <button id="btnStartEdit" class="cmd-btn btn-full" onclick="startZoneEdit()" style="margin-top:5px; background: #00bcd4; color: #1a1a1a;">Draw / Edit Selected Zone</button>
                    <button class="cmd-btn btn-full btn-danger" onclick="deleteZone()" style="margin-top:5px;">Delete Selected Zone</button>
                </div>
            </section>
            <section class="panel-section" data-tab-panels="zones">
                <div class="panel-section-title">Presence Controls</div>
                <div class="config-content">
                    <div class="panel-lede">
                        Core motion behavior settings for occupancy timing, sensitivity, and load control.
                    </div>
                    <div id="schemaPresenceControlsFields" class="schema-fields-shell">
                        <div class="schema-loading-note">Loading controls...</div>
                    </div>
                </div>
            </section>
            </div>

            <div class="zones-pane" id="zonesPaneConfig" role="tabpanel" aria-labelledby="zonesPaneTabConfig" data-zones-pane="config" data-tab-panels="zones">
            <section class="panel-section">
                <div class="panel-section-title">Presence Configuration</div>
                <div class="config-content">
                    <div class="panel-lede">
                        Room profile and set-and-forget motion configuration values.
                    </div>
                    <div id="schemaPresenceConfigFields" class="schema-fields-shell">
                        <div class="schema-loading-note">Loading controls...</div>
                    </div>
                </div>
            </section>
            <section class="panel-section">
                <div class="panel-section-title">Maintenance Tools</div>
                <div class="config-content">
                    <button class="cmd-btn btn-full" onclick="sendCommand(1)">Auto-Config Interference</button>
                    <button class="cmd-btn btn-full btn-danger" onclick="sendCommand(3)">Clear Interference</button>
                    <div style="height: 10px;"></div>
                    <button class="cmd-btn btn-full" onclick="sendCommand(4)">Reset Detection Zones</button>
                    <button class="cmd-btn btn-full" onclick="sendCommand(5)">Clear Stay Zones</button>
                    <div class="config-title" style="margin-top: 12px;">Command Feedback</div>
                    <div id="commandLog" class="command-log">
                        <div class="command-log-empty">No command activity yet.</div>
                    </div>
                </div>
            </section>
            </div>

            <div class="zones-pane" id="zonesPaneView" role="tabpanel" aria-labelledby="zonesPaneTabView" data-zones-pane="view" data-tab-panels="zones">
            <section class="panel-section">
                <div class="panel-section-title">Studio View Settings</div>
                <div class="config-content">
                    <div style="margin-top:5px; padding-top:5px;">
                        <div style="font-size:0.9em; font-weight:bold; color:#00bcd4; margin-bottom:5px;">Connection Behavior</div>
                        <div class="input-row">
                            <label for="targetReportAutoOffToggle">Auto-off reporting on disconnect:</label>
                            <input type="checkbox" id="targetReportAutoOffToggle">
                        </div>
                    </div>
                    
                    <div style="margin-top:10px; padding-top:5px;">
                        <div style="font-size:0.9em; font-weight:bold; color:#00bcd4; margin-bottom:5px;">Map Visibility</div>
                        <div class="input-row">
                            <label for="vizToggleGrid">Show Radar Grid:</label>
                            <input type="checkbox" id="vizToggleGrid" checked>
                        </div>
                        <div class="input-row">
                            <label for="vizToggleLabels">Show Labels:</label>
                            <input type="checkbox" id="vizToggleLabels" checked>
                        </div>
                        <div class="input-row">
                            <label for="vizToggleZValues">Show Zone Heights:</label>
                            <input type="checkbox" id="vizToggleZValues">
                        </div>
                        <div class="input-row">
                            <label style="color:#00bcd4" for="vizToggleDetection">Show Detection Zones:</label>
                            <input type="checkbox" id="vizToggleDetection" checked>
                        </div>
                        <!-- Individual Detection Toggles -->
                        <div id="detectionSubOptions" style="margin-left: 20px; display: block; border-left: 1px solid #444; padding-left: 10px;">
                            <div class="input-row" style="margin-bottom: 2px;">
                                <label style="font-size: 0.85em;">Area 1 (Primary)</label>
                                <input type="checkbox" id="vizToggleDetection1" checked>
                            </div>
                            <div class="input-row" style="margin-bottom: 2px;">
                                <label style="font-size: 0.85em;">Area 2</label>
                                <input type="checkbox" id="vizToggleDetection2" checked>
                            </div>
                            <div class="input-row" style="margin-bottom: 2px;">
                                <label style="font-size: 0.85em;">Area 3</label>
                                <input type="checkbox" id="vizToggleDetection3" checked>
                            </div>
                            <div class="input-row">
                                <label style="font-size: 0.85em;">Area 4</label>
                                <input type="checkbox" id="vizToggleDetection4" checked>
                            </div>
                        </div>

                        <div class="input-row" style="margin-top: 5px;">
                            <label style="color:#ff9800" for="vizToggleStay">Show Stay Zones:</label>
                            <input type="checkbox" id="vizToggleStay" checked>
                        </div>
                        <div class="input-row">
                            <label style="color:#ff5252" for="vizToggleInterference">Show Interference Zones:</label>
                            <input type="checkbox" id="vizToggleInterference" checked>
                        </div>
                    </div>
                    
                    <div class="config-title" style="margin-top: 15px; border-top: 1px solid #444; padding-top: 5px;">Radar Map Size (cm)</div>
                    <div class="zone-data-grid">
                        <div class="zone-input-group"><label>X Min</label><input type="number" id="vizXMin" value="-650"></div>
                        <div class="zone-input-group"><label>X Max</label><input type="number" id="vizXMax" value="650"></div>
                        <div class="zone-input-group"><label>Y Min</label><input type="number" id="vizYMin" value="-50"></div>
                        <div class="zone-input-group"><label>Y Max</label><input type="number" id="vizYMax" value="650"></div>
                    </div>
                    <button class="cmd-btn btn-full" onclick="updateRadarScale()" style="margin-top:5px; background: #00bcd4; color: #1a1a1a;">Update Scale</button>
                </div>
            </section>
            </div>

            <div class="config-tab-shell" data-tab-panels="load">
                <section class="panel-section" data-tab-section="load-main">
                    <div class="panel-section-title">Load & Dimming</div>
                    <div class="config-content">
                        <div class="panel-lede">Frequently adjusted dimming behavior, ramp timing, and paddle response settings.</div>
                        <div id="schemaLoadFields" class="schema-fields-shell">
                            <div class="schema-loading-note">Loading controls...</div>
                        </div>
                    </div>
                </section>
            </div>

            <div class="config-tab-shell" data-tab-panels="led">
                <section class="panel-section" data-tab-section="led-main">
                    <div class="panel-section-title">LED & Notifications</div>
                    <div class="config-content">
                        <div class="panel-lede">Color presets, brightness levels, and notification effects that users tend to tune often.</div>
                        <div id="schemaLedFields" class="schema-fields-shell">
                            <div class="schema-loading-note">Loading controls...</div>
                        </div>
                    </div>
                </section>
            </div>

            <div class="config-tab-shell" data-tab-panels="buttons">
                <section class="panel-section" data-tab-section="buttons-main">
                    <div class="panel-section-title">Buttons & Scenes</div>
                    <div class="config-content">
                        <div class="panel-lede">Tap and scene behavior mappings for paddle actions and automation events.</div>
                        <div id="schemaButtonFields" class="schema-fields-shell">
                            <div class="schema-loading-note">Loading controls...</div>
                        </div>
                    </div>
                </section>
            </div>

            <div class="config-tab-shell" data-tab-panels="power">
                <section class="panel-section" data-tab-section="power-main">
                    <div class="panel-section-title">Power & Device</div>
                    <div class="config-content">
                        <div class="panel-lede">Power reporting, protection, and device-level operational settings.</div>
                        <div id="schemaPowerFields" class="schema-fields-shell">
                            <div class="schema-loading-note">Loading controls...</div>
                        </div>
                    </div>
                </section>
            </div>

            <div class="config-tab-shell" data-tab-panels="advanced">
                <section class="panel-section" data-tab-section="advanced-main">
                    <div class="panel-section-title">Advanced Settings</div>
                    <div class="config-content">
                        <div class="panel-lede">
                            Set-and-forget settings. Most users only need to change these during initial setup.
                        </div>
                        <div id="schemaAdvancedFields" class="schema-fields-shell">
                            <div class="schema-loading-note">Loading advanced settings...</div>
                        </div>
                    </div>
                </section>

                <section class="panel-section conditional-section" data-tab-section="advanced-fan" data-conditional-section="fan-parameters">
                    <div class="panel-section-title">Fan Parameters (May Not Apply)</div>
                    <div class="config-content">
                        <div class="panel-lede" style="color: #ffcc80;">
                            These values are shared firmware fields and may not function on VZM32-SN.
                        </div>
                        <div id="schemaFanFields" class="schema-fields-shell">
                            <div class="schema-loading-note">Loading fan-related fields...</div>
                        </div>
                    </div>
                </section>
            </div>

            <div class="dirty-bar" id="dirtyBar" hidden>
                <span id="dirtyText">No pending changes</span>
                <div class="dirty-actions">
                    <button class="dirty-btn" id="btnDiscardChanges" type="button" disabled>Discard</button>
                    <button class="dirty-btn apply-btn" id="btnApplyChanges" type="button" disabled>Apply Changes</button>
                </div>
            </div>

        </div>
    </div>

    <script src="{{ ingress_path }}/static/js/app_tabs.js"></script>
    <script src="{{ ingress_path }}/static/js/app_state.js"></script>
    <script src="{{ ingress_path }}/static/js/app_zones.js"></script>
    <script>
        const INGRESS_PATH = "{{ ingress_path }}";
        const SWITCH_STUDIO_UI_ENABLED = {{ 'true' if switch_studio_ui else 'false' }};
        const socket = io({ path: INGRESS_PATH + '/socket.io' });

        const statusDiv = document.getElementById('statusDiv');
        const packetInfo = document.getElementById('packetInfo');
        const timestampSpan = document.getElementById('timestamp');
        const packetAgeSpan = document.getElementById('packetAge');
        const deviceSelect = document.getElementById('deviceSelect');
        const dataTableBody = document.getElementById('dataTableBody');
        const tabBar = document.getElementById('tabBar');
        const appContainer = document.getElementById('appContainer');

        // UI Elements
        const nonMmwaveWarning = document.getElementById('nonMmwaveWarning');
        const configSidebar = document.getElementById('configSidebar');
        const btnForceSync = document.getElementById('btnForceSync');
        const occupancyVal = document.getElementById('occupancyVal');
        const illuminanceVal = document.getElementById('illuminanceVal');
        const dirtyBar = document.getElementById('dirtyBar');
        const dirtyText = document.getElementById('dirtyText');
        const btnApplyChanges = document.getElementById('btnApplyChanges');
        const btnDiscardChanges = document.getElementById('btnDiscardChanges');
        const toastContainer = document.getElementById('toastContainer');
        const commandLog = document.getElementById('commandLog');
        const targetReportToggle = document.getElementById('targetReportToggle');
        const targetReportAutoOffToggle = document.getElementById('targetReportAutoOffToggle');
        const stripIlluminanceVal = document.getElementById('stripIlluminanceVal');
        const stripTargetReportState = document.getElementById('stripTargetReportState');
        const zonesSidebarTabs = document.getElementById('zonesSidebarTabs');
        const zonesSidebarTabButtons = Array.from(document.querySelectorAll('[data-zones-pane-target]'));
        const zonesSidebarPanes = Array.from(document.querySelectorAll('[data-zones-pane]'));
        const connectionChip = document.getElementById('connectionChip');
        const connectionText = document.getElementById('connectionText');
        const TARGET_REPORT_AUTO_OFF_STORAGE_KEY = 'switchStudio.targetReportAutoOff';
        const ZONES_SIDEBAR_TAB_STORAGE_KEY = 'switchStudio.zonesSidebarTab';

        // Visualizer Scale Inputs
        const vizXMin = document.getElementById('vizXMin');
        const vizXMax = document.getElementById('vizXMax');
        const vizYMin = document.getElementById('vizYMin');
        const vizYMax = document.getElementById('vizYMax');

        let targetHistory = {}; 
        const HISTORY_LENGTH = 15; 
        let activeZonesSidebarPane = 'controls';
        
        // Interaction Lock for Jitter Prevention
        let isInteracting = false;
        
        const chartElement = document.getElementById('chart');
        
        // Listeners to detect dragging/interacting
        chartElement.addEventListener('mousedown', () => { isInteracting = true; });
        chartElement.addEventListener('mouseup', () => { isInteracting = false; });
        chartElement.addEventListener('mouseleave', () => { isInteracting = false; });
        chartElement.addEventListener('touchstart', () => { isInteracting = true; }, {passive: true});
        chartElement.addEventListener('touchend', () => { isInteracting = false; });
        
        // Zone Management State
        let deviceZones = {
            // Unify: Area1 is now the Primary zone
            mmwave_detection_areas: { area1: null, area2: null, area3: null, area4: null },
            mmwave_interference_areas: { area1: null, area2: null, area3: null, area4: null },
            mmwave_stay_areas: { area1: null, area2: null, area3: null, area4: null }
        };
        let occupancyState = { global: null, area1: null, area2: null, area3: null, area4: null };

        // Zone Editing State
        let isEditingZone = false;
        let editingTarget = null;
        let draftZoneConfig = null;
        
        const zoneEditorSelect = document.getElementById('zoneEditorSelect');
        const zoneEditorRawData = document.getElementById('zoneEditorRawData');
        const btnStartEdit = document.getElementById('btnStartEdit');

        // Inputs for Raw Data
        const editXMin = document.getElementById('editXMin');
        const editXMax = document.getElementById('editXMax');
        const editYMin = document.getElementById('editYMin');
        const editYMax = document.getElementById('editYMax');
        const editZMin = document.getElementById('editZMin');
        const editZMax = document.getElementById('editZMax');
        const schemaPresenceControlsFields = document.getElementById('schemaPresenceControlsFields');
        const schemaPresenceConfigFields = document.getElementById('schemaPresenceConfigFields');
        const schemaLoadFields = document.getElementById('schemaLoadFields');
        const schemaLedFields = document.getElementById('schemaLedFields');
        const schemaButtonFields = document.getElementById('schemaButtonFields');
        const schemaPowerFields = document.getElementById('schemaPowerFields');
        const schemaAdvancedFields = document.getElementById('schemaAdvancedFields');
        const schemaFanFields = document.getElementById('schemaFanFields');

        let schemaModel = null;
        let schemaFieldMap = {};
        let schemaCompositeMap = {};
        let zoneModule = null;

        function parsePanelTargets(raw) {
            if (!raw) return [];
            return raw
                .split(',')
                .map(item => item.trim())
                .filter(Boolean);
        }

        function parseOccupancyValue(value) {
            if (value === true || value === 'ON' || value === 1 || value === '1') return true;
            if (value === false || value === 'OFF' || value === 0 || value === '0') return false;
            if (typeof value === 'string') {
                const lowered = value.trim().toLowerCase();
                if (lowered === 'true' || lowered === 'detected') return true;
                if (lowered === 'false' || lowered === 'clear') return false;
            }
            return null;
        }

        function setAreaStatusIndicators(areaIndex, isDetected) {
            const badge = document.getElementById(`area${areaIndex}Val`);
            const pill = document.getElementById(`area${areaIndex}Pill`);
            const pillState = document.getElementById(`area${areaIndex}PillState`);
            const active = isDetected === true;
            const stateText = active ? 'DETECTED' : 'CLEAR';

            if (badge) {
                badge.innerText = stateText;
                badge.className = active ? 'zone-badge zone-active' : 'zone-badge';
            }
            if (pillState) {
                pillState.textContent = stateText;
            }
            if (pill) {
                pill.classList.toggle('zone-live-pill-active', active);
            }
        }

        function setMapStandbyState(isStandby) {
            // Standby map chip removed from UI per product feedback.
            return !!isStandby;
        }

        function hasActiveOccupancy() {
            const states = Object.values(occupancyState).filter(v => v === true || v === false);
            if (states.length === 0) return true;
            return states.some(v => v === true);
        }

        function clearTargetsForOccupancyGate() {
            setMapStandbyState(false);
            if (zoneModule && typeof zoneModule.clearTargetVisualization === 'function') {
                zoneModule.clearTargetVisualization('No targets detected');
                return;
            }
            targetHistory = {};
            const chartDiv = document.getElementById('chart');
            if (chartDiv && chartDiv.data && window.Plotly) {
                Plotly.restyle('chart', { x: [[]], y: [[]], text: [[]] }, [0]);
                Plotly.restyle('chart', { x: [[]], y: [[]] }, [1]);
            }
            dataTableBody.innerHTML = '<tr><td colspan="5" class="no-data">No targets detected</td></tr>';
        }

        function applyLayoutMode(activeTab) {
            if (!appContainer) return;
            const tab = String(activeTab || '').toLowerCase();
            const zoneFocused = tab === 'zones';
            appContainer.classList.toggle('focus-zones', zoneFocused);
            appContainer.classList.toggle('focus-config', !zoneFocused);
        }

        function normalizeZonesSidebarPane(paneName) {
            const raw = String(paneName || '').trim().toLowerCase();
            if (raw === 'controls' || raw === 'config' || raw === 'view') return raw;
            return 'controls';
        }

        function getStoredZonesSidebarPane() {
            try {
                return normalizeZonesSidebarPane(localStorage.getItem(ZONES_SIDEBAR_TAB_STORAGE_KEY));
            } catch (err) {
                return 'controls';
            }
        }

        function applyZonesSidebarPane(paneName) {
            const normalizedPane = normalizeZonesSidebarPane(paneName);
            activeZonesSidebarPane = normalizedPane;

            zonesSidebarTabButtons.forEach(button => {
                const target = normalizeZonesSidebarPane(button.getAttribute('data-zones-pane-target'));
                const isActive = target === normalizedPane;
                button.classList.toggle('active', isActive);
                button.setAttribute('aria-selected', String(isActive));
                button.tabIndex = isActive ? 0 : -1;
            });

            zonesSidebarPanes.forEach(panel => {
                const target = normalizeZonesSidebarPane(panel.getAttribute('data-zones-pane'));
                const isActive = target === normalizedPane;
                panel.classList.toggle('is-active', isActive);
                panel.style.display = isActive ? '' : 'none';
                panel.hidden = !isActive;
                panel.setAttribute('aria-hidden', String(!isActive));
            });

            try {
                localStorage.setItem(ZONES_SIDEBAR_TAB_STORAGE_KEY, normalizedPane);
            } catch (err) {
                // Ignore storage failures.
            }
        }

        function initZonesSidebarTabs() {
            if (!zonesSidebarTabs || zonesSidebarTabButtons.length === 0 || zonesSidebarPanes.length === 0) return;
            activeZonesSidebarPane = getStoredZonesSidebarPane();

            zonesSidebarTabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const nextPane = button.getAttribute('data-zones-pane-target');
                    if (!nextPane) return;
                    applyZonesSidebarPane(nextPane);
                });
            });

            zonesSidebarTabs.addEventListener('keydown', (event) => {
                const key = event.key;
                if (!['ArrowLeft', 'ArrowRight', 'Home', 'End'].includes(key)) return;

                const currentIndex = zonesSidebarTabButtons.findIndex(button =>
                    normalizeZonesSidebarPane(button.getAttribute('data-zones-pane-target')) === activeZonesSidebarPane
                );
                if (currentIndex < 0) return;

                event.preventDefault();
                let nextIndex = currentIndex;
                if (key === 'ArrowRight') nextIndex = (currentIndex + 1) % zonesSidebarTabButtons.length;
                if (key === 'ArrowLeft') nextIndex = (currentIndex - 1 + zonesSidebarTabButtons.length) % zonesSidebarTabButtons.length;
                if (key === 'Home') nextIndex = 0;
                if (key === 'End') nextIndex = zonesSidebarTabButtons.length - 1;

                const nextButton = zonesSidebarTabButtons[nextIndex];
                if (!nextButton) return;
                const nextPane = nextButton.getAttribute('data-zones-pane-target');
                applyZonesSidebarPane(nextPane);
                nextButton.focus();
            });

            applyZonesSidebarPane(activeZonesSidebarPane);
        }

        function setConnectionState(isConnected) {
            if (!connectionChip || !connectionText) return;
            const connected = !!isConnected;
            connectionChip.classList.toggle('offline', !connected);
            connectionText.textContent = connected ? 'Connected' : 'Disconnected';
        }

        function updateDeviceSelectState() {
            if (!deviceSelect) return;
            const hasSelection = !!String(deviceSelect.value || '').trim();
            deviceSelect.classList.toggle('device-unselected', !hasSelection);
            deviceSelect.setAttribute('aria-label', hasSelection ? 'Select a Device' : 'Select a Device (required)');
        }

        function applyLegacyLayout() {
            if (tabBar) {
                tabBar.style.display = 'none';
            }

            try {
                localStorage.removeItem('switchStudio.activeTab');
            } catch (err) {
                // Ignore storage failures.
            }

            const allowedPanels = new Set(['zones', 'advanced']);
            const panels = Array.from(document.querySelectorAll('[data-tab-panels]'));
            panels.forEach(panel => {
                const targets = parsePanelTargets(panel.getAttribute('data-tab-panels'));
                const shouldShow = targets.length === 0 || targets.some(target => allowedPanels.has(target));
                panel.style.display = shouldShow ? '' : 'none';
            });
        }

        if (SWITCH_STUDIO_UI_ENABLED && window.SwitchStudioTabs && typeof window.SwitchStudioTabs.init === 'function') {
            window.SwitchStudioTabs.init({
                defaultTab: 'zones',
                onTabChange: (activeTab) => {
                    applyLayoutMode(activeTab);
                    if (String(activeTab || '').toLowerCase() === 'zones') {
                        applyZonesSidebarPane(activeZonesSidebarPane);
                        setTimeout(() => {
                            const chartDiv = document.getElementById('chart');
                            if (chartDiv && chartDiv.data) {
                                Plotly.Plots.resize(chartDiv);
                            }
                        }, 40);
                    }
                }
            });
        } else {
            applyLegacyLayout();
            applyLayoutMode('zones');
        }
        updateDeviceSelectState();
        initZonesSidebarTabs();

        if (window.SwitchStudioState && typeof window.SwitchStudioState.init === 'function') {
            window.SwitchStudioState.init({
                socket: socket,
                packetInfoEl: packetInfo,
                dirtyBarEl: dirtyBar,
                dirtyTextEl: dirtyText,
                applyBtnEl: btnApplyChanges,
                discardBtnEl: btnDiscardChanges,
                toastContainerEl: toastContainer
            });
        }

        function getStoredTargetReportingAutoOff() {
            try {
                return localStorage.getItem(TARGET_REPORT_AUTO_OFF_STORAGE_KEY) === '1';
            } catch (err) {
                return false;
            }
        }

        function persistTargetReportingAutoOff(enabled) {
            try {
                localStorage.setItem(TARGET_REPORT_AUTO_OFF_STORAGE_KEY, enabled ? '1' : '0');
            } catch (err) {
                // Ignore storage failures.
            }
        }

        function parseTargetReportingEnabled(value) {
            if (value === true || value === 'ON') return true;
            if (value === false || value === 'OFF') return false;
            const raw = String(value || '').trim().toLowerCase();
            if (!raw) return false;
            if (raw.includes('disable')) return false;
            if (raw.includes('enable')) return true;
            return false;
        }

        function setTargetReportingState(enabled, rawValue) {
            const isEnabled = !!enabled;
            if (targetReportToggle) {
                targetReportToggle.checked = isEnabled;
            }
            if (stripTargetReportState) {
                stripTargetReportState.textContent = isEnabled ? 'ON' : 'OFF';
                stripTargetReportState.classList.toggle('zones-report-on', isEnabled);
                stripTargetReportState.classList.toggle('zones-report-off', !isEnabled);
            }
        }

        function syncTargetReportingAutoOffPreference() {
            const enabled = targetReportAutoOffToggle ? !!targetReportAutoOffToggle.checked : false;
            socket.emit('set_reporting_auto_off', { enabled: enabled });
            if (window.SwitchStudioState) {
                window.SwitchStudioState.setPacketStatus('info', enabled ? 'Auto-off armed on disconnect' : 'Auto-off disabled');
            }
        }

        if (targetReportAutoOffToggle) {
            targetReportAutoOffToggle.checked = getStoredTargetReportingAutoOff();
            targetReportAutoOffToggle.addEventListener('change', () => {
                persistTargetReportingAutoOff(!!targetReportAutoOffToggle.checked);
                syncTargetReportingAutoOffPreference();
            });
        }

        if (targetReportToggle) {
            targetReportToggle.addEventListener('change', () => {
                const enabled = !!targetReportToggle.checked;
                const requestId = `target-report-${Date.now()}`;
                socket.emit('set_target_reporting', { enabled: enabled, request_id: requestId });
                if (window.SwitchStudioState) {
                    window.SwitchStudioState.setPacketStatus('syncing', enabled ? 'Enabling target reporting...' : 'Disabling target reporting...');
                } else {
                    packetInfo.innerText = enabled ? 'Enabling target reporting...' : 'Disabling target reporting...';
                }
            });
        }
        setTargetReportingState(false, 'Disable');

        function getInputValueForEmit(input) {
            if (!input) return '';
            if (input.type === 'checkbox') return input.checked;

            const fieldType = input.dataset.fieldType;
            if (fieldType === 'numeric') {
                if (input.value === '') return '';
                const parsed = Number(input.value);
                return Number.isFinite(parsed) ? parsed : input.value;
            }

            if (fieldType === 'list') {
                const raw = (input.value || '').trim();
                if (!raw) return [];
                const itemType = input.dataset.itemType || '';
                return raw
                    .split(',')
                    .map(v => v.trim())
                    .filter(Boolean)
                    .map(v => {
                        if (itemType === 'numeric') {
                            const n = Number(v);
                            return Number.isFinite(n) ? n : v;
                        }
                        return v;
                    });
            }

            return input.value;
        }

        const friendlyLabelMap = {
            // Presence & Zones
            mmwaveControlWiredDevice: 'Presence -> Light Behavior',
            mmWaveRoomSizePreset: 'Room Size Preset',
            mmWaveHoldTime: 'Vacancy Timeout',
            mmWaveDetectSensitivity: 'Presence Sensitivity',
            mmWaveDetectTrigger: 'Detection Response Speed',
            mmWaveTargetInfoReport: 'Live Position Reporting',
            mmWaveStayLife: 'Stationary Detection Duration',
            mmWaveHeightMin: 'Height Min (Z)',
            mmWaveHeightMax: 'Height Max (Z)',
            mmWaveWidthMin: 'Width Min (X)',
            mmWaveWidthMax: 'Width Max (X)',
            mmWaveDepthMin: 'Depth Min (Y)',
            mmWaveDepthMax: 'Depth Max (Y)',
            mmwave_control_commands: 'mmWave Commands (Advanced)',
            mmwave_interference_areas: 'Interference Zones (Advanced)',
            mmwave_detection_areas: 'Detection Zones (Advanced)',
            mmwave_stay_areas: 'Stay Zones (Advanced)',

            // Load & Dimming
            dimmingSpeedUpRemote: 'Dim Up Speed (Hub)',
            dimmingSpeedUpLocal: 'Dim Up Speed (Paddle)',
            rampRateOffToOnRemote: 'Ramp On Speed (Hub)',
            rampRateOffToOnLocal: 'Ramp On Speed (Paddle)',
            dimmingSpeedDownRemote: 'Dim Down Speed (Hub)',
            dimmingSpeedDownLocal: 'Dim Down Speed (Paddle)',
            rampRateOnToOffRemote: 'Ramp Off Speed (Hub)',
            rampRateOnToOffLocal: 'Ramp Off Speed (Paddle)',
            invertSwitch: 'Invert Paddle Direction',
            autoTimerOff: 'Auto-Off Timer',
            defaultLevelLocal: 'Default Level (Paddle)',
            defaultLevelRemote: 'Default Level (Hub)',
            stateAfterPowerRestored: 'Power Restore State',
            loadLevelIndicatorTimeout: 'Level Indicator Timeout',
            switchType: 'Wiring Type',
            smartBulbMode: 'Smart Bulb Mode',
            bindingOffToOnSyncLevel: 'Bind Uses Default Level',
            minimumLevel: 'Minimum Dim Level',
            maximumLevel: 'Maximum Dim Level',
            outputMode: 'Switch Mode (Dimmer / On-Off)',
            quickStartTime: 'Quick Start Time',
            quickStartLevel: 'Quick Start Level',
            higherOutputInNonNeutral: 'Unthrottled Output (No Neutral)',

            // LED & Notifications
            led_effect: 'LED Effect (All LEDs)',
            individual_led_effect: 'LED Effect (Single LED)',
            ledColorWhenOn: 'All LEDs Color (On)',
            ledColorWhenOff: 'All LEDs Color (Off)',
            ledIntensityWhenOn: 'All LEDs Brightness (On)',
            ledIntensityWhenOff: 'All LEDs Brightness (Off)',
            ledColorForFanControlMode: 'Fan Mode LED Color',
            onOffLedMode: 'Single LED Mode (Bottom Only)',
            firmwareUpdateInProgressIndicator: 'Firmware Progress LED',
            doubleTapClearNotifications: 'Double-Tap Clears Notifications',
            fanLedLevelType: 'Fan LED Display Mode',
            ledBarScaling: 'LED Bar Scaling (Gen 2 Match)',
            defaultLed1ColorWhenOn: 'LED 1 Color (On)',
            defaultLed1ColorWhenOff: 'LED 1 Color (Off)',
            defaultLed1IntensityWhenOn: 'LED 1 Brightness (On)',
            defaultLed1IntensityWhenOff: 'LED 1 Brightness (Off)',
            defaultLed2ColorWhenOn: 'LED 2 Color (On)',
            defaultLed2ColorWhenOff: 'LED 2 Color (Off)',
            defaultLed2IntensityWhenOn: 'LED 2 Brightness (On)',
            defaultLed2IntensityWhenOff: 'LED 2 Brightness (Off)',
            defaultLed3ColorWhenOn: 'LED 3 Color (On)',
            defaultLed3ColorWhenOff: 'LED 3 Color (Off)',
            defaultLed3IntensityWhenOn: 'LED 3 Brightness (On)',
            defaultLed3IntensityWhenOff: 'LED 3 Brightness (Off)',
            defaultLed4ColorWhenOn: 'LED 4 Color (On)',
            defaultLed4ColorWhenOff: 'LED 4 Color (Off)',
            defaultLed4IntensityWhenOn: 'LED 4 Brightness (On)',
            defaultLed4IntensityWhenOff: 'LED 4 Brightness (Off)',
            defaultLed5ColorWhenOn: 'LED 5 Color (On)',
            defaultLed5ColorWhenOff: 'LED 5 Color (Off)',
            defaultLed5IntensityWhenOn: 'LED 5 Brightness (On)',
            defaultLed5IntensityWhenOff: 'LED 5 Brightness (Off)',
            defaultLed6ColorWhenOn: 'LED 6 Color (On)',
            defaultLed6ColorWhenOff: 'LED 6 Color (Off)',
            defaultLed6IntensityWhenOn: 'LED 6 Brightness (On)',
            defaultLed6IntensityWhenOff: 'LED 6 Brightness (Off)',
            defaultLed7ColorWhenOn: 'LED 7 Color (On)',
            defaultLed7ColorWhenOff: 'LED 7 Color (Off)',
            defaultLed7IntensityWhenOn: 'LED 7 Brightness (On)',
            defaultLed7IntensityWhenOff: 'LED 7 Brightness (Off)',
            notificationComplete: 'Last Notification Cleared',

            // Buttons & Scenes
            buttonDelay: 'Multi-Tap Delay',
            doubleTapUpToParam55: 'Enable Double-Tap Up',
            doubleTapDownToParam56: 'Enable Double-Tap Down',
            brightnessLevelForDoubleTapUp: 'Double-Tap Up Level',
            brightnessLevelForDoubleTapDown: 'Double-Tap Down Level',
            singleTapBehavior: 'Single-Tap Behavior (Fan Mode)',
            auxSwitchUniqueScenes: 'Aux Unique Scenes',

            // Power & Device
            fanControlMode: 'Fan Control Mode',
            lowLevelForFanControlMode: 'Fan Low Level',
            mediumLevelForFanControlMode: 'Fan Medium Level',
            highLevelForFanControlMode: 'Fan High Level',
            fanTimerMode: 'Fan Timer Mode',
            localProtection: 'Local Control Lock',
            activePowerReports: 'Power Report Threshold',
            periodicPowerAndEnergyReports: 'Periodic Report Interval',
            activeEnergyReports: 'Energy Report Threshold',
            otaImageType: 'OTA Image Type',
            identify: 'Identify Device',
            energy_reset: 'Reset Energy Counter',

            // Runtime Options
            power_calibration: 'Power Calibration (%)',
            power_precision: 'Power Precision',
            voltage_calibration: 'Voltage Calibration (%)',
            voltage_precision: 'Voltage Precision',
            current_calibration: 'Current Calibration (%)',
            current_precision: 'Current Precision',
            energy_calibration: 'Energy Calibration (%)',
            energy_precision: 'Energy Precision',
            illuminance_calibration: 'Illuminance Calibration',
            transition: 'Transition Time',
            identify_timeout: 'Identify Timeout',
            state_action: 'Publish Action Events',
            illuminance_raw: 'Publish Raw Illuminance',
            no_occupancy_since: 'Vacancy Alert Intervals',

            // Read-only
            mmWaveVersion: 'mmWave Firmware Version',
            dimmingMode: 'Dimming Method (Leading / Trailing)',
            remoteProtection: 'Remote Control Lock',
            powerType: 'Wiring Detection (Neutral / Non-Neutral)',
            internalTemperature: 'Internal Temperature',
            overheat: 'Overheat Status',
            deviceBindNumber: 'Bound Device Count',

            // Live state
            occupancy: 'Presence Detected',
            illuminance: 'Ambient Light (lux)',
            power: 'Active Power (W)',
            voltage: 'Line Voltage (V)',
            current: 'Current Draw (A)',
            energy: 'Total Energy (kWh)',
            action: 'Last Scene Event',
            linkquality: 'Zigbee Link Quality',
            area1Occupancy: 'Area 1 Presence',
            area2Occupancy: 'Area 2 Presence',
            area3Occupancy: 'Area 3 Presence',
            area4Occupancy: 'Area 4 Presence',

            // Composite features
            effect: 'Effect Pattern',
            color: 'Color Preset',
            level: 'Brightness',
            duration: 'Duration',
            led: 'Target LED',
            command: 'mmWave Command',
            area1: 'Area 1',
            area2: 'Area 2',
            area3: 'Area 3',
            area4: 'Area 4'
        };

        const compositeFeatureLabelOverrides = {
            led_effect: {
                effect: 'Effect Pattern',
                color: 'Color Preset',
                level: 'Brightness',
                duration: 'Duration'
            },
            individual_led_effect: {
                led: 'Target LED',
                effect: 'Effect Pattern',
                color: 'Color Preset',
                level: 'Brightness',
                duration: 'Duration'
            },
            mmwave_control_commands: {
                command: 'mmWave Command'
            },
            mmwave_interference_areas: {
                area1: 'Area 1',
                area2: 'Area 2',
                area3: 'Area 3',
                area4: 'Area 4'
            },
            mmwave_detection_areas: {
                area1: 'Area 1',
                area2: 'Area 2',
                area3: 'Area 3',
                area4: 'Area 4'
            },
            mmwave_stay_areas: {
                area1: 'Area 1',
                area2: 'Area 2',
                area3: 'Area 3',
                area4: 'Area 4'
            }
        };

        const enumOptionLabelOverrides = {
            invertSwitch: {
                Yes: 'Yes - Inverted (Up = Off)',
                No: 'No - Normal (Up = On)'
            },
            smartBulbMode: {
                Disabled: 'Disabled',
                'Smart Bulb Mode': 'Enabled'
            },
            onOffLedMode: {
                All: 'All LEDs',
                One: 'Bottom LED Only'
            },
            doubleTapClearNotifications: {
                'Enabled (Default)': 'Enabled',
                Disabled: 'Disabled'
            },
            higherOutputInNonNeutral: {
                'Disabled (default)': 'Disabled',
                Enabled: 'Enabled'
            },
            mmWaveTargetInfoReport: {
                'Disable (default)': 'Disable',
                Enable: 'Enable'
            },
            ledBarScaling: {
                'Gen3 method (VZM-style)': 'Gen 3 (VZM style)',
                'Gen2 method (LZW-style)': 'Gen 2 (LZW style)'
            }
        };

        function looksHumanReadableLabel(label) {
            const text = String(label || '').trim();
            if (!text) return false;
            if (text.includes(' ')) return true;
            return !/[a-z][A-Z]/.test(text);
        }

        function humanizeSchemaKey(name) {
            if (!name) return '';
            let text = String(name)
                .replace(/_/g, ' ')
                .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
                .replace(/([A-Za-z])([0-9])/g, '$1 $2')
                .replace(/([0-9])([A-Za-z])/g, '$1 $2')
                .replace(/\s+/g, ' ')
                .trim();

            const tokens = text.split(' ').map(token => {
                const lower = token.toLowerCase();
                if (lower === 'led') return 'LED';
                if (lower === 'ota') return 'OTA';
                if (lower === 'id') return 'ID';
                if (lower === 'zigbee') return 'Zigbee';
                if (/^\d+$/.test(token)) return token;
                return lower.charAt(0).toUpperCase() + lower.slice(1);
            });

            text = tokens.join(' ');
            text = text.replace(/\bMm Wave\b/g, 'mmWave');
            return text;
        }

        function getFriendlyLabel(name, fallbackLabel) {
            if (name && friendlyLabelMap[name]) return friendlyLabelMap[name];
            if (looksHumanReadableLabel(fallbackLabel)) return String(fallbackLabel).trim();
            if (name) return humanizeSchemaKey(name);
            return fallbackLabel || 'Unknown';
        }

        function getReadableFieldLabel(field) {
            if (!field) return 'Unknown';
            return getFriendlyLabel(field.name, field.label);
        }

        function getReadableFeatureLabel(parentField, feature) {
            if (!feature) return 'Unknown';
            const parentName = parentField && parentField.name ? parentField.name : '';
            const featureName = feature.name || '';
            const parentOverrides = parentName ? compositeFeatureLabelOverrides[parentName] : null;
            if (parentOverrides && featureName && parentOverrides[featureName]) {
                return parentOverrides[featureName];
            }
            return getFriendlyLabel(featureName, feature.label);
        }

        function getReadableEnumOptionLabel(fieldName, optionValue) {
            const raw = optionValue === undefined || optionValue === null ? '' : String(optionValue);
            if (!raw) return raw;
            const fieldOverrides = fieldName ? enumOptionLabelOverrides[fieldName] : null;
            if (fieldOverrides && Object.prototype.hasOwnProperty.call(fieldOverrides, raw)) {
                return fieldOverrides[raw];
            }
            if (raw === 'Yes') return 'Enabled';
            if (raw === 'No') return 'Disabled';
            if (raw === 'True') return 'Enabled';
            if (raw === 'False') return 'Disabled';
            return raw;
        }

        const defaultLedColorPresets = [
            { name: 'Red', value: 0 },
            { name: 'Orange', value: 21 },
            { name: 'Yellow', value: 42 },
            { name: 'Green', value: 85 },
            { name: 'Cyan', value: 127 },
            { name: 'Blue', value: 170 },
            { name: 'Violet', value: 212 },
            { name: 'Pink', value: 234 },
            { name: 'White', value: 255 }
        ];

        const concisePresenceDescriptions = {
            mmwaveControlWiredDevice: 'Choose how presence controls the wired load.',
            mmWaveRoomSizePreset: 'Pick a room profile, or use Custom for manual zone tuning.',
            mmWaveHoldTime: 'How long occupancy stays active after motion stops.',
            mmWaveDetectSensitivity: 'Sensitivity for movement detection.',
            mmWaveDetectTrigger: 'How quickly movement triggers occupancy.',
            mmWaveTargetInfoReport: 'Streams live target coordinates to the radar map.',
            mmWaveStayLife: 'Tuning value for stationary-presence retention.',
            mmWaveVersion: 'Current firmware version of the mmWave module.'
        };

        function isLedField(field) {
            if (!field) return false;
            const tabKey = mapFieldTabToKey(field, 'fields');
            if (tabKey === 'led') return true;
            const parentTab = String(field.parent_tab || '').toLowerCase();
            if (parentTab.includes('led')) return true;
            const parentName = String(field.parent_name || '').toLowerCase();
            if (parentName.includes('led')) return true;
            const fieldName = String(field.name || '').toLowerCase();
            return fieldName.includes('led') || fieldName.includes('notification');
        }

        function isLedColorField(field) {
            if (!field || field.type !== 'numeric' || !isLedField(field)) return false;
            return String(field.name || '').toLowerCase().includes('color');
        }

        function isLedBrightnessField(field) {
            if (!field || field.type !== 'numeric' || !isLedField(field)) return false;
            const name = String(field.name || '').toLowerCase();
            return name.includes('intensity') || name === 'level';
        }

        function fieldUsesSyncDefaultColor(field) {
            const name = String((field && field.name) || '').toLowerCase();
            if (/^defaultled[1-7]colorwhen(on|off)$/.test(name)) return true;
            const description = String((field && field.description) || '').toLowerCase();
            return description.includes('synchronization with default all led strip color parameter');
        }

        function normalizeColorPreset(preset) {
            if (!preset || preset.value === undefined || preset.value === null) return null;
            const numericValue = Number(preset.value);
            if (!Number.isFinite(numericValue)) return null;
            return {
                value: numericValue,
                name: preset.name ? String(preset.name) : `Value ${numericValue}`
            };
        }

        function getLedColorPresets(field) {
            const explicitPresets = Array.isArray(field && field.presets) ? field.presets.map(normalizeColorPreset).filter(Boolean) : [];
            if (explicitPresets.length > 0) return explicitPresets;

            if (fieldUsesSyncDefaultColor(field)) {
                return defaultLedColorPresets
                    .filter(preset => preset.value !== 255)
                    .concat([{ name: 'Sync Default', value: 255 }]);
            }

            return defaultLedColorPresets.slice();
        }

        function setLedColorSelectValue(select, value) {
            if (!select || select.tagName !== 'SELECT') return;
            const normalizedValue = value === undefined || value === null ? '' : String(value);

            Array.from(select.options)
                .filter(option => option.dataset.customColorValue === '1')
                .forEach(option => option.remove());

            if (!normalizedValue) {
                select.selectedIndex = -1;
                return;
            }

            const existingOption = Array.from(select.options).find(option => option.value === normalizedValue);
            if (existingOption) {
                select.value = normalizedValue;
                return;
            }

            const customOption = document.createElement('option');
            customOption.value = normalizedValue;
            customOption.textContent = `Current (${normalizedValue})`;
            customOption.dataset.customColorValue = '1';
            select.appendChild(customOption);
            select.value = normalizedValue;
        }

        function formatLedSliderValue(input) {
            if (!input) return '--';
            const rawValue = input.value === '' ? '--' : String(input.value);
            const maxValue = Number(input.max);
            if (rawValue !== '--' && maxValue === 101 && Number(rawValue) === 101) {
                return 'Sync';
            }
            return rawValue === '--' ? '--' : `${rawValue}%`;
        }

        function refreshLedSliderDisplay(input) {
            if (!input) return;
            const targetId = input.dataset.sliderValueTarget;
            if (!targetId) return;
            const valueElement = document.getElementById(targetId);
            if (!valueElement) return;
            valueElement.textContent = formatLedSliderValue(input);
        }

        function createLedColorPresetControl(field, inputId) {
            const select = document.createElement('select');
            select.className = 'control-select led-color-select';
            select.id = inputId;
            select.setAttribute('data-param', field.name);
            select.setAttribute('data-field-type', 'numeric');
            select.setAttribute('data-led-color-select', '1');

            getLedColorPresets(field).forEach(preset => {
                const option = document.createElement('option');
                option.value = String(preset.value);
                option.textContent = preset.name;
                select.appendChild(option);
            });
            return select;
        }

        function createLedBrightnessControl(field, inputId) {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-control';

            const input = document.createElement('input');
            input.type = 'range';
            input.id = inputId;
            input.setAttribute('data-param', field.name);
            input.setAttribute('data-field-type', 'numeric');
            input.setAttribute('data-led-brightness-slider', '1');
            if (field.value_min !== null && field.value_min !== undefined) input.min = field.value_min;
            if (field.value_max !== null && field.value_max !== undefined) input.max = field.value_max;
            if (field.value_step !== null && field.value_step !== undefined) input.step = field.value_step;
            else input.step = '1';
            if (field.value_min !== null && field.value_min !== undefined) input.value = String(field.value_min);

            const value = document.createElement('span');
            value.className = 'slider-value';
            value.id = `${inputId}__value`;
            input.dataset.sliderValueTarget = value.id;

            input.addEventListener('input', () => refreshLedSliderDisplay(input));
            input.addEventListener('change', () => refreshLedSliderDisplay(input));

            wrapper.appendChild(input);
            wrapper.appendChild(value);
            refreshLedSliderDisplay(input);
            return wrapper;
        }

        function getConciseLedDescription(field) {
            if (!field) return '';
            if (isLedColorField(field)) return 'Choose an LED color preset.';
            if (isLedBrightnessField(field)) return 'Adjust LED brightness.';
            return field.description || '';
        }

        function getConciseFieldDescription(field) {
            if (!field || !field.name) return field && field.description ? field.description : '';
            const tabKey = mapFieldTabToKey(field, 'fields');
            if (tabKey === 'presence') {
                return concisePresenceDescriptions[field.name] || field.description || '';
            }
            if (tabKey === 'led') {
                return getConciseLedDescription(field);
            }
            return field.description || '';
        }

        function mapFieldTabToKey(field, sourceType) {
            const tab = String((field && field.tab) || '').toLowerCase();
            if (tab === 'presence') return 'presence';
            if (tab === 'zones') return 'zones';
            if (tab === 'live') return 'live';
            if (tab === 'load & dimming') return 'load';
            if (tab === 'led & notifications') return 'led';
            if (tab === 'buttons & scenes') return 'buttons';
            if (tab === 'power & device') return 'power';
            if (tab === 'advanced') return 'power';
            if (sourceType === 'options') return 'power';
            return 'power';
        }

        const hiddenFieldKeys = new Set([
            // Controlled via dedicated top-level toggle card in the zones view.
            'mmWaveTargetInfoReport'
        ]);

        const fanFieldKeys = new Set([
            'fanControlMode',
            'fanTimerMode',
            'lowLevelForFanControlMode',
            'mediumLevelForFanControlMode',
            'highLevelForFanControlMode',
            'fanLedLevelType',
            'ledColorForFanControlMode',
            'singleTapBehavior'
        ]);
        const presenceConfigOnlyFieldKeys = new Set([
            'mmWaveRoomSizePreset'
        ]);

        const advancedFieldKeys = new Set([
            // Presence set-and-forget tuning.
            'mmWaveStayLife',
            'mmWaveHeightMin',
            'mmWaveHeightMax',
            'mmWaveWidthMin',
            'mmWaveWidthMax',
            'mmWaveDepthMin',
            'mmWaveDepthMax',

            // Load/switch setup parameters.
            'switchType',
            'outputMode',
            'invertSwitch',
            'smartBulbMode',
            'bindingOffToOnSyncLevel',
            'higherOutputInNonNeutral',
            'minimumLevel',
            'maximumLevel',
            'stateAfterPowerRestored',
            'autoTimerOff',
            'quickStartTime',
            'quickStartLevel',
            'localProtection',
            'otaImageType'
        ]);

        function isFieldHiddenByDedicatedControl(field) {
            return !!(field && field.name && hiddenFieldKeys.has(field.name));
        }

        function isFanField(field) {
            return !!(field && field.name && fanFieldKeys.has(field.name));
        }

        function isSetAndForgetField(field, sourceType) {
            if (!field || !field.name) return false;
            if (sourceType === 'options') return true;
            return advancedFieldKeys.has(field.name);
        }

        function createSchemaFieldInput(field, inputIdOverride) {
            const inputId = inputIdOverride || field.name;

            if (field.type === 'enum') {
                const select = document.createElement('select');
                select.className = 'control-select';
                select.id = inputId;
                select.setAttribute('data-param', field.name);
                select.setAttribute('data-field-type', field.type);
                (field.values || []).forEach(optionValue => {
                    const option = document.createElement('option');
                    option.value = optionValue;
                    option.textContent = getReadableEnumOptionLabel(field.name, optionValue);
                    select.appendChild(option);
                });
                return select;
            }

            if (field.type === 'binary') {
                const select = document.createElement('select');
                select.className = 'control-select';
                select.id = inputId;
                select.setAttribute('data-param', field.name);
                select.setAttribute('data-field-type', field.type);

                const onValue = field.value_on !== undefined ? field.value_on : true;
                const offValue = field.value_off !== undefined ? field.value_off : false;
                const entries = [
                    { value: onValue, label: `On (${String(onValue)})` },
                    { value: offValue, label: `Off (${String(offValue)})` }
                ];

                entries.forEach(entry => {
                    const option = document.createElement('option');
                    option.value = typeof entry.value === 'boolean' ? String(entry.value) : entry.value;
                    option.textContent = entry.label;
                    select.appendChild(option);
                });
                return select;
            }

            if (field.type === 'numeric') {
                if (isLedColorField(field)) {
                    return createLedColorPresetControl(field, inputId);
                }
                if (isLedBrightnessField(field)) {
                    return createLedBrightnessControl(field, inputId);
                }
                const input = document.createElement('input');
                input.type = 'number';
                input.id = inputId;
                input.setAttribute('data-param', field.name);
                input.setAttribute('data-field-type', field.type);
                if (field.value_min !== null && field.value_min !== undefined) input.min = field.value_min;
                if (field.value_max !== null && field.value_max !== undefined) input.max = field.value_max;
                if (field.value_step !== null && field.value_step !== undefined) input.step = field.value_step;
                return input;
            }

            if (field.type === 'list') {
                const input = document.createElement('input');
                input.type = 'text';
                input.id = inputId;
                input.className = 'full-width-select';
                input.placeholder = 'comma-separated values';
                input.setAttribute('data-param', field.name);
                input.setAttribute('data-field-type', field.type);
                if (field.item_type && field.item_type.type) {
                    input.setAttribute('data-item-type', field.item_type.type);
                }
                return input;
            }

            const unsupported = document.createElement('span');
            unsupported.className = 'zone-badge';
            unsupported.innerText = `Unsupported type: ${field.type || 'unknown'}`;
            return unsupported;
        }

        function createSchemaDescriptionRow(text, parent) {
            if (!text) return;
            const desc = document.createElement('div');
            desc.className = 'schema-description';
            desc.textContent = text;
            parent.appendChild(desc);
        }

        function createReadOnlyValueElement(field) {
            const readOnlyVal = document.createElement('span');
            readOnlyVal.id = field.name;
            readOnlyVal.className = 'sensor-val schema-readonly-value';
            readOnlyVal.innerText = '--';
            return readOnlyVal;
        }

        function createSchemaFieldRow(field) {
            const row = document.createElement('div');
            row.className = 'input-row schema-field-row';

            const label = document.createElement('label');
            label.setAttribute('for', field.name);
            label.textContent = getReadableFieldLabel(field) + (field.unit ? ` (${field.unit})` : '') + ':';
            row.appendChild(label);

            if (field.can_write) {
                row.appendChild(createSchemaFieldInput(field));
            } else {
                row.appendChild(createReadOnlyValueElement(field));
            }
            return row;
        }

        function getCompositeFeatureInputId(fieldName, featureName) {
            return `${fieldName}__${featureName}`;
        }

        function resolveCompositeControlInput(control, inputId) {
            if (!control) return null;
            if (control.id === inputId) return control;
            if (typeof control.querySelector === 'function') {
                return control.querySelector(`[id="${inputId}"]`);
            }
            return null;
        }

        function createCompositeFeatureInput(parentField, feature) {
            const fieldName = parentField && parentField.name ? parentField.name : '';
            const featureField = {
                ...feature,
                name: feature.name,
                value_on: feature.value_on,
                value_off: feature.value_off,
                parent_tab: parentField ? parentField.tab : '',
                parent_name: fieldName,
            };
            const inputId = getCompositeFeatureInputId(fieldName, feature.name);
            const control = createSchemaFieldInput(featureField, inputId);
            const controlInput = resolveCompositeControlInput(control, inputId);
            if (controlInput) {
                controlInput.removeAttribute('data-param');
                controlInput.setAttribute('data-composite-parent', fieldName);
                controlInput.setAttribute('data-composite-feature', feature.name);
            }
            return control;
        }

        function collectCompositePayload(field) {
            const payload = {};
            const features = Array.isArray(field.features) ? field.features : [];

            for (const feature of features) {
                if (!feature || !feature.name || feature.type === 'composite') continue;
                const inputId = getCompositeFeatureInputId(field.name, feature.name);
                const input = document.getElementById(inputId);
                if (!input) continue;

                let value = getInputValueForEmit(input);
                if (feature.type === 'binary' && typeof value === 'string') {
                    if (value === 'true') value = true;
                    else if (value === 'false') value = false;
                }
                if (feature.type === 'numeric' && value === '') {
                    throw new Error(`${getReadableFeatureLabel(field, feature)} cannot be empty`);
                }

                const payloadKey = feature.property || feature.name;
                payload[payloadKey] = value;
            }
            return payload;
        }

        function sendCompositeUpdate(field) {
            try {
                const payload = collectCompositePayload(field);
                socket.emit('update_parameter', {
                    param: field.name,
                    value: payload,
                    request_id: `composite-${Date.now()}-${field.name}`
                });
                if (window.SwitchStudioState) {
                    window.SwitchStudioState.setPacketStatus('syncing', `${getReadableFieldLabel(field)} update sent`);
                    window.SwitchStudioState.showToast('syncing', `${getReadableFieldLabel(field)} update sent`, 1600);
                }
            } catch (err) {
                const message = err && err.message ? err.message : 'Failed to build composite payload';
                if (window.SwitchStudioState) {
                    window.SwitchStudioState.setPacketStatus('error', message);
                    window.SwitchStudioState.showToast('error', message, 2600);
                } else {
                    packetInfo.innerText = `Error: ${message}`;
                }
            }
        }

        function renderCompositeField(field, container) {
            const block = document.createElement('div');
            block.className = 'schema-composite-block';

            const title = document.createElement('div');
            title.className = 'schema-composite-title';
            title.textContent = getReadableFieldLabel(field);
            block.appendChild(title);

            const features = Array.isArray(field.features) ? field.features : [];
            if (features.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'schema-composite-note';
                empty.textContent = 'No editable features available for this composite.';
                block.appendChild(empty);
                container.appendChild(block);
                return;
            }

            features.forEach(feature => {
                if (!feature || !feature.name || feature.type === 'composite') return;
                const row = document.createElement('div');
                row.className = 'input-row schema-field-row';

                const label = document.createElement('label');
                label.setAttribute('for', getCompositeFeatureInputId(field.name, feature.name));
                label.textContent = `${getReadableFeatureLabel(field, feature)}${feature.unit ? ` (${feature.unit})` : ''}:`;
                row.appendChild(label);
                row.appendChild(createCompositeFeatureInput(field, feature));
                block.appendChild(row);
            });

            if (field.can_write) {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'cmd-btn btn-full';
                button.style.marginTop = '5px';
                button.innerText = `Send ${getReadableFieldLabel(field)}`;
                button.addEventListener('click', () => sendCompositeUpdate(field));
                block.appendChild(button);
            }

            if (field.description) {
                const note = document.createElement('div');
                note.className = 'schema-composite-note';
                note.textContent = field.description;
                block.appendChild(note);
            }

            container.appendChild(block);
        }

        function orderPresenceFields(fields) {
            const presenceNames = schemaModel && Array.isArray(schemaModel.mmwave_presence_fields)
                ? schemaModel.mmwave_presence_fields
                : [];
            const byName = new Map(fields.map(field => [field.name, field]));
            const ordered = [];
            const used = new Set();

            presenceNames.forEach(name => {
                const field = byName.get(name);
                if (field) {
                    ordered.push(field);
                    used.add(name);
                }
            });

            fields.forEach(field => {
                if (!used.has(field.name)) ordered.push(field);
            });
            return ordered;
        }

        function renderSchemaFieldCollection(container, fields, emptyMessage) {
            if (!container) return;
            container.innerHTML = '';
            container.classList.add('schema-fields-shell');

            if (!fields || fields.length === 0) {
                container.innerHTML = `<div class="schema-empty-note">${emptyMessage}</div>`;
                return;
            }

            const grouped = {};
            fields.forEach(field => {
                const section = field.section || 'General';
                if (!grouped[section]) grouped[section] = [];
                grouped[section].push(field);
            });

            Object.keys(grouped).forEach(section => {
                const sectionBlock = document.createElement('div');
                sectionBlock.className = 'schema-section-block';

                const sectionTitle = document.createElement('div');
                sectionTitle.className = 'schema-section-title';
                sectionTitle.textContent = section;
                sectionBlock.appendChild(sectionTitle);

                grouped[section].forEach(field => {
                    schemaFieldMap[field.name] = field;

                    if (field.type === 'composite') {
                        schemaCompositeMap[field.name] = field;
                        renderCompositeField(field, sectionBlock);
                        return;
                    }

                    sectionBlock.appendChild(createSchemaFieldRow(field));
                    createSchemaDescriptionRow(getConciseFieldDescription(field), sectionBlock);
                });

                container.appendChild(sectionBlock);
            });
        }

        function renderAllSchemaFields() {
            if (!schemaModel || !Array.isArray(schemaModel.fields)) {
                const unavailable = '<div class="schema-empty-note">Schema unavailable.</div>';
                if (schemaPresenceControlsFields) schemaPresenceControlsFields.innerHTML = unavailable;
                if (schemaPresenceConfigFields) schemaPresenceConfigFields.innerHTML = unavailable;
                if (schemaLoadFields) schemaLoadFields.innerHTML = unavailable;
                if (schemaLedFields) schemaLedFields.innerHTML = unavailable;
                if (schemaButtonFields) schemaButtonFields.innerHTML = unavailable;
                if (schemaPowerFields) schemaPowerFields.innerHTML = unavailable;
                if (schemaAdvancedFields) schemaAdvancedFields.innerHTML = unavailable;
                if (schemaFanFields) schemaFanFields.innerHTML = unavailable;
                return;
            }

            schemaFieldMap = {};
            schemaCompositeMap = {};

            const fields = schemaModel.fields.filter(field => field && field.name);
            const options = Array.isArray(schemaModel.options) ? schemaModel.options.filter(opt => opt && opt.name) : [];

            const buckets = {
                presence: [],
                load: [],
                led: [],
                buttons: [],
                power: [],
                advanced: [],
                fan: []
            };

            fields.forEach(field => {
                if (isFieldHiddenByDedicatedControl(field)) return;

                if (isFanField(field)) {
                    buckets.fan.push({ ...field, section: 'Fan Parameters (May Not Apply)' });
                    return;
                }

                if (isSetAndForgetField(field, 'fields')) {
                    buckets.advanced.push({ ...field, section: field.section || 'Set-and-Forget' });
                    return;
                }

                const tabKey = mapFieldTabToKey(field, 'fields');
                if (tabKey === 'presence') buckets.presence.push(field);
                else if (tabKey === 'load') buckets.load.push(field);
                else if (tabKey === 'led') buckets.led.push(field);
                else if (tabKey === 'buttons') buckets.buttons.push(field);
                else if (tabKey === 'power') buckets.power.push(field);
            });

            const optionFields = options.map(option => ({ ...option, section: option.section || 'Runtime Options' }));
            buckets.advanced.push(...optionFields);

            const presenceFields = orderPresenceFields(buckets.presence);
            const loadFields = buckets.load;
            const ledFields = buckets.led;
            const buttonFields = buckets.buttons;
            const powerFields = buckets.power;
            const advancedFields = buckets.advanced;
            const fanFields = buckets.fan;

            const presenceControlsFields = presenceFields.filter(field => !presenceConfigOnlyFieldKeys.has(field.name));
            const presenceConfigFields = presenceFields.filter(field => presenceConfigOnlyFieldKeys.has(field.name));
            renderSchemaFieldCollection(schemaPresenceControlsFields, presenceControlsFields, 'No presence controls found.');
            renderSchemaFieldCollection(schemaPresenceConfigFields, presenceConfigFields, 'No presence configuration fields found.');
            renderSchemaFieldCollection(schemaLoadFields, loadFields, 'No load or dimming controls found.');
            renderSchemaFieldCollection(schemaLedFields, ledFields, 'No LED fields found in schema.');
            renderSchemaFieldCollection(schemaButtonFields, buttonFields, 'No button or scene fields found.');
            renderSchemaFieldCollection(schemaPowerFields, powerFields, 'No power/device fields found.');
            renderSchemaFieldCollection(schemaAdvancedFields, advancedFields, 'No advanced settings found.');
            renderSchemaFieldCollection(schemaFanFields, fanFields, 'No fan-specific fields exposed for this device.');
        }

        function syncCompositeSchemaInputs(config) {
            if (!config || typeof config !== 'object') return;
            Object.entries(schemaCompositeMap).forEach(([fieldName, field]) => {
                if (!(fieldName in config)) return;
                const compositeValue = config[fieldName];
                if (!compositeValue || typeof compositeValue !== 'object') return;

                const features = Array.isArray(field.features) ? field.features : [];
                features.forEach(feature => {
                    if (!feature || !feature.name) return;
                    const inputId = getCompositeFeatureInputId(fieldName, feature.name);
                    const input = document.getElementById(inputId);
                    if (!input) return;

                    const key = feature.property || feature.name;
                    if (!(key in compositeValue)) return;
                    const value = compositeValue[key];

                    if (input.dataset.ledColorSelect === '1') {
                        setLedColorSelectValue(input, value);
                    } else if (input.type === 'checkbox') {
                        input.checked = value === true || value === 'ON' || value === 'true';
                    } else if (input.tagName === 'SELECT' && typeof value === 'boolean') {
                        input.value = String(value);
                    } else if (Array.isArray(value)) {
                        input.value = value.join(', ');
                    } else if (value !== undefined && value !== null) {
                        input.value = value;
                    } else {
                        input.value = '';
                    }

                    if (input.dataset.ledBrightnessSlider === '1') {
                        refreshLedSliderDisplay(input);
                    }
                });
            });
        }

        // Packet Aging Logic
        let lastPacketTime = null;
        
        setInterval(() => {
            if (lastPacketTime) {
                const age = (Date.now() - lastPacketTime) / 1000;
                packetAgeSpan.innerText = `(${age.toFixed(1)}s ago)`;
                if (age > 5) packetAgeSpan.style.color = '#ff5252';
                else if (age > 2) packetAgeSpan.style.color = '#ff9800';
                else packetAgeSpan.style.color = '#666';
            } else {
                packetAgeSpan.innerText = "";
            }
        }, 100);

        // Context-aware command tracking
        let lastCommandId = null; 

        // Support future conditional tab sections without reworking layout scaffolding.
        function setConditionalSectionVisibility(sectionName, isVisible) {
            const key = String(sectionName || '').trim();
            if (!key) return;
            const sections = document.querySelectorAll(`[data-conditional-section="${key}"]`);
            sections.forEach((section) => {
                section.hidden = !isVisible;
            });
        }

        function applyConditionalSectionVisibility(map) {
            if (!map || typeof map !== 'object') return;
            Object.entries(map).forEach(([sectionName, isVisible]) => {
                setConditionalSectionVisibility(sectionName, !!isVisible);
            });
        }

        window.SwitchStudioSections = {
            setSectionVisibility: setConditionalSectionVisibility,
            setSectionsVisibility: applyConditionalSectionVisibility
        };

        // Responsive Resize Handler
        window.addEventListener('resize', function() {
            Plotly.Plots.resize('chart');
            // Prevent mobile keyboard from triggering layout collapse
        });

        // Helper: Update Timestamp
        function updateTimestamp() {
            const now = new Date();
            timestampSpan.innerText = now.toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second:'2-digit' }) + '.' + now.getMilliseconds().toString().padStart(3, '0');
            lastPacketTime = Date.now();
        }

        // --- Visualizer Settings Logic ---
        let showInterference = true;
        let showDetection = true;
        let showStay = true;
        let showGrid = true;
        let showLabels = true;
        let showZValues = false;
        
        // Individual Detection Toggles
        let showDetection1 = true;
        let showDetection2 = true;
        let showDetection3 = true;
        let showDetection4 = true;
        
        // Custom Scale Defaults
        let chartXMin = -650;
        let chartXMax = 650;
        let chartYMin = -50;
        let chartYMax = 650;

        // Init Settings from LocalStorage
        try {
            if (localStorage.getItem('vizShowInterference') !== null) showInterference = localStorage.getItem('vizShowInterference') === 'true';
            if (localStorage.getItem('vizShowDetection') !== null) showDetection = localStorage.getItem('vizShowDetection') === 'true';
            if (localStorage.getItem('vizShowStay') !== null) showStay = localStorage.getItem('vizShowStay') === 'true';
            if (localStorage.getItem('vizShowGrid') !== null) showGrid = localStorage.getItem('vizShowGrid') === 'true';
            if (localStorage.getItem('vizShowLabels') !== null) showLabels = localStorage.getItem('vizShowLabels') === 'true';
            if (localStorage.getItem('vizShowZValues') !== null) showZValues = localStorage.getItem('vizShowZValues') === 'true';
            
            // Sub detection toggles
            if (localStorage.getItem('vizShowDetection1') !== null) showDetection1 = localStorage.getItem('vizShowDetection1') === 'true';
            if (localStorage.getItem('vizShowDetection2') !== null) showDetection2 = localStorage.getItem('vizShowDetection2') === 'true';
            if (localStorage.getItem('vizShowDetection3') !== null) showDetection3 = localStorage.getItem('vizShowDetection3') === 'true';
            if (localStorage.getItem('vizShowDetection4') !== null) showDetection4 = localStorage.getItem('vizShowDetection4') === 'true';
            
            if (localStorage.getItem('vizXMin') !== null) chartXMin = parseInt(localStorage.getItem('vizXMin'));
            if (localStorage.getItem('vizXMax') !== null) chartXMax = parseInt(localStorage.getItem('vizXMax'));
            if (localStorage.getItem('vizYMin') !== null) chartYMin = parseInt(localStorage.getItem('vizYMin'));
            if (localStorage.getItem('vizYMax') !== null) chartYMax = parseInt(localStorage.getItem('vizYMax'));
        } catch(e) { console.log('Storage access error', e); }

        const vizToggleInterference = document.getElementById('vizToggleInterference');
        const vizToggleDetection = document.getElementById('vizToggleDetection');
        const vizToggleStay = document.getElementById('vizToggleStay');
        const vizToggleGrid = document.getElementById('vizToggleGrid');
        const vizToggleLabels = document.getElementById('vizToggleLabels');
        const vizToggleZValues = document.getElementById('vizToggleZValues');
        
        // Sub Toggles
        const vizToggleDetection1 = document.getElementById('vizToggleDetection1');
        const vizToggleDetection2 = document.getElementById('vizToggleDetection2');
        const vizToggleDetection3 = document.getElementById('vizToggleDetection3');
        const vizToggleDetection4 = document.getElementById('vizToggleDetection4');
        
        // Set inputs to loaded values
        vizXMin.value = chartXMin;
        vizXMax.value = chartXMax;
        vizYMin.value = chartYMin;
        vizYMax.value = chartYMax;

        function applyVizSettings() {
            // Set checkboxes
            if (vizToggleInterference) vizToggleInterference.checked = showInterference;
            if (vizToggleDetection) vizToggleDetection.checked = showDetection;
            if (vizToggleStay) vizToggleStay.checked = showStay;
            if (vizToggleGrid) vizToggleGrid.checked = showGrid;
            if (vizToggleLabels) vizToggleLabels.checked = showLabels;
            if (vizToggleZValues) vizToggleZValues.checked = showZValues;
            
            if (vizToggleDetection1) vizToggleDetection1.checked = showDetection1;
            if (vizToggleDetection2) vizToggleDetection2.checked = showDetection2;
            if (vizToggleDetection3) vizToggleDetection3.checked = showDetection3;
            if (vizToggleDetection4) vizToggleDetection4.checked = showDetection4;
            
            // Only update Plotly if the chart exists
            const chartDiv = document.getElementById('chart');
            if (chartDiv && chartDiv.layout) {
                // Update both shapes and annotations (labels)
                Plotly.relayout('chart', {
                    shapes: getChartShapes(),
                    annotations: getChartAnnotations()
                });
            }
        }
        
        function updateRadarScale() {
            chartXMin = parseInt(vizXMin.value);
            chartXMax = parseInt(vizXMax.value);
            chartYMin = parseInt(vizYMin.value);
            chartYMax = parseInt(vizYMax.value);
            
            localStorage.setItem('vizXMin', chartXMin);
            localStorage.setItem('vizXMax', chartXMax);
            localStorage.setItem('vizYMin', chartYMin);
            localStorage.setItem('vizYMax', chartYMax);
            
            const chartDiv = document.getElementById('chart');
            if (chartDiv && chartDiv.layout) {
                Plotly.relayout('chart', {
                    'xaxis.range': [chartXMin, chartXMax],
                    'yaxis.range': [chartYMin, chartYMax]
                });
            }
        }

        // Attach Listeners
        if (vizToggleInterference) vizToggleInterference.addEventListener('change', (e) => { showInterference = e.target.checked; localStorage.setItem('vizShowInterference', showInterference); applyVizSettings(); });
        if (vizToggleDetection) vizToggleDetection.addEventListener('change', (e) => { showDetection = e.target.checked; localStorage.setItem('vizShowDetection', showDetection); applyVizSettings(); });
        if (vizToggleStay) vizToggleStay.addEventListener('change', (e) => { showStay = e.target.checked; localStorage.setItem('vizShowStay', showStay); applyVizSettings(); });
        if (vizToggleGrid) vizToggleGrid.addEventListener('change', (e) => { showGrid = e.target.checked; localStorage.setItem('vizShowGrid', showGrid); applyVizSettings(); });
        if (vizToggleLabels) vizToggleLabels.addEventListener('change', (e) => { showLabels = e.target.checked; localStorage.setItem('vizShowLabels', showLabels); applyVizSettings(); });
        if (vizToggleZValues) vizToggleZValues.addEventListener('change', (e) => { showZValues = e.target.checked; localStorage.setItem('vizShowZValues', showZValues); applyVizSettings(); });

        if (vizToggleDetection1) vizToggleDetection1.addEventListener('change', (e) => { showDetection1 = e.target.checked; localStorage.setItem('vizShowDetection1', showDetection1); applyVizSettings(); });
        if (vizToggleDetection2) vizToggleDetection2.addEventListener('change', (e) => { showDetection2 = e.target.checked; localStorage.setItem('vizShowDetection2', showDetection2); applyVizSettings(); });
        if (vizToggleDetection3) vizToggleDetection3.addEventListener('change', (e) => { showDetection3 = e.target.checked; localStorage.setItem('vizShowDetection3', showDetection3); applyVizSettings(); });
        if (vizToggleDetection4) vizToggleDetection4.addEventListener('change', (e) => { showDetection4 = e.target.checked; localStorage.setItem('vizShowDetection4', showDetection4); applyVizSettings(); });

        function getFovBoundaryPoint(halfAngleDegrees, direction) {
            const halfAngleRad = (Math.PI / 180) * halfAngleDegrees;
            const tanHalf = Math.tan(halfAngleRad);
            if (!Number.isFinite(tanHalf) || tanHalf <= 0) return { x: 0, y: 0 };

            const yCeiling = Math.max(0, chartYMax);
            const isRight = direction >= 0;
            const xLimit = isRight ? Math.max(0, chartXMax) : Math.min(0, chartXMin);
            const xAtTop = (isRight ? 1 : -1) * yCeiling * tanHalf;

            if ((isRight && xAtTop <= xLimit) || (!isRight && xAtTop >= xLimit)) {
                return { x: xAtTop, y: yCeiling };
            }
            return { x: xLimit, y: Math.min(yCeiling, Math.abs(xLimit) / tanHalf) };
        }

        function buildFovSectorPath(halfAngleDegrees) {
            const right = getFovBoundaryPoint(halfAngleDegrees, 1);
            const left = getFovBoundaryPoint(halfAngleDegrees, -1);
            const topY = Math.max(0, chartYMax);
            const rightTouchesTop = Math.abs(right.y - topY) < 0.5;
            const leftTouchesTop = Math.abs(left.y - topY) < 0.5;
            const points = [[0, 0], [right.x, right.y]];

            if (!rightTouchesTop) points.push([Math.max(0, chartXMax), topY]);
            if (!leftTouchesTop) points.push([Math.min(0, chartXMin), topY]);
            points.push([left.x, left.y], [0, 0]);

            return `M ${points.map(([x, y]) => `${x} ${y}`).join(' L ')} Z`;
        }

        function buildVerticalBandShapes() {
            // Disabled per feedback: keep radar background clean with no vertical bands.
            return [];
        }

        // Radar Rings - Generate fresh objects
        function getRadarRings() {
            if (!showGrid) return []; // Grid Toggle

            const rings = buildVerticalBandShapes();
            const fovOuterPath = buildFovSectorPath(75);  // 150-degree upper bound
            const fovInnerPath = buildFovSectorPath(60);  // 120-degree lower bound

            rings.push({
                type: 'path',
                xref: 'x',
                yref: 'y',
                path: fovOuterPath,
                fillcolor: 'rgba(13, 212, 192, 0.06)',
                line: { color: 'rgba(0, 188, 212, 0.0)', width: 0 },
                editable: false,
                layer: 'below'
            });
            rings.push({
                type: 'path',
                xref: 'x',
                yref: 'y',
                path: fovInnerPath,
                fillcolor: 'rgba(13, 212, 192, 0.09)',
                line: { color: 'rgba(0, 188, 212, 0.0)', width: 0 },
                editable: false,
                layer: 'below'
            });
            const fovOuterRight = getFovBoundaryPoint(75, 1);
            const fovOuterLeft = getFovBoundaryPoint(75, -1);
            const fovBoundaryRight = getFovBoundaryPoint(60, 1);
            const fovBoundaryLeft = getFovBoundaryPoint(60, -1);
            rings.push({
                type: 'line', xref: 'x', yref: 'y',
                x0: 0, y0: 0, x1: fovBoundaryRight.x, y1: fovBoundaryRight.y,
                line: { color: 'rgba(13, 212, 192, 0.32)', width: 1.5 },
                editable: false,
                layer: 'below'
            });
            rings.push({
                type: 'line', xref: 'x', yref: 'y',
                x0: 0, y0: 0, x1: fovBoundaryLeft.x, y1: fovBoundaryLeft.y,
                line: { color: 'rgba(13, 212, 192, 0.32)', width: 1.5 },
                editable: false,
                layer: 'below'
            });
            rings.push({
                type: 'line', xref: 'x', yref: 'y',
                x0: 0, y0: 0, x1: fovOuterRight.x, y1: fovOuterRight.y,
                line: { color: 'rgba(13, 212, 192, 0.14)', width: 1.1, dash: 'dot' },
                editable: false,
                layer: 'below'
            });
            rings.push({
                type: 'line', xref: 'x', yref: 'y',
                x0: 0, y0: 0, x1: fovOuterLeft.x, y1: fovOuterLeft.y,
                line: { color: 'rgba(13, 212, 192, 0.14)', width: 1.1, dash: 'dot' },
                editable: false,
                layer: 'below'
            });
            [100, 200, 300, 400, 500, 600].forEach((dist) => {
                rings.push({
                    type: 'circle', xref: 'x', yref: 'y',
                    x0: -dist, x1: dist, y0: -dist, y1: dist,
                    line: { color: 'rgba(176, 198, 216, 0.08)', width: dist % 200 === 0 ? 1.05 : 0.8, dash: 'dot' },
                    editable: false,
                    layer: 'below'
                });
            });
            rings.push({
                type: 'line', xref: 'x', yref: 'y',
                x0: chartXMin, y0: 0, x1: chartXMax, y1: 0,
                line: { color: 'rgba(13, 212, 192, 0.3)', width: 1.2 },
                editable: false,
                layer: 'below'
            });
            rings.push({
                type: 'circle', xref: 'x', yref: 'y',
                x0: -18, x1: 18, y0: -18, y1: 18,
                fillcolor: 'rgba(255, 111, 111, 0.24)',
                line: { color: 'rgba(255, 111, 111, 0.56)', width: 1.2 },
                editable: false,
                layer: 'below'
            });
            rings.push({
                type: 'circle', xref: 'x', yref: 'y',
                x0: -8, x1: 8, y0: -8, y1: 8,
                fillcolor: 'rgba(255, 111, 111, 0.92)',
                line: { color: 'rgba(255, 255, 255, 0.85)', width: 1.2 },
                editable: false,
                layer: 'below'
            });
            return rings;
        }

        function getChartShapes() {
            let shapes = getRadarRings(); 
            let activeDraftShape = null;

            // Helper to decide opacity
            const getOpacity = (isTarget) => {
                if (!isEditingZone) return 0.6; // Normal opacity
                return isTarget ? 0.8 : 0.1;    // Highlight target, dim others
            };

            // 2. DETECTION AREAS
            if (showDetection) {
                Object.entries(deviceZones.mmwave_detection_areas).forEach(([areaId, config]) => {
                    // Check individual sub-toggles
                    let isVisible = true;
                    if (areaId === 'area1' && !showDetection1) isVisible = false;
                    if (areaId === 'area2' && !showDetection2) isVisible = false;
                    if (areaId === 'area3' && !showDetection3) isVisible = false;
                    if (areaId === 'area4' && !showDetection4) isVisible = false;

                    if (isVisible) {
                        const targetKey = `mmwave_detection_areas:${areaId}`;
                        const isArea1 = areaId === 'area1';
                        // Area 1 is Blue (Primary), others are Green (Secondary)
                        const color = isArea1 ? 'rgba(0, 188, 212, 0.8)' : 'rgba(76, 175, 80, 0.9)'; 
                        
                        if (isEditingZone && editingTarget === targetKey) {
                            if (draftZoneConfig) activeDraftShape = createShapeObj(draftZoneConfig, color, `rgba(0, 188, 212, 0.2)`, true);
                        } else if (config && !isEditingZone) {
                            shapes.push(createShapeObj(config, color.replace('0.8', '0.6').replace('0.9', '0.6'), color.replace('0.8', '0.1').replace('0.9', '0.1'), false));
                        }
                    }
                });
            }

            // 3. STAY AREAS (Orange)
            if (showStay) {
                Object.entries(deviceZones.mmwave_stay_areas).forEach(([areaId, config]) => {
                    const targetKey = `mmwave_stay_areas:${areaId}`;
                    if (isEditingZone && editingTarget === targetKey) {
                        if (draftZoneConfig) activeDraftShape = createShapeObj(draftZoneConfig, 'rgba(255, 152, 0, 0.9)', 'rgba(255, 152, 0, 0.2)', true);
                    } else if (config && !isEditingZone) {
                        shapes.push(createShapeObj(config, `rgba(255, 152, 0, 0.6)`, 'rgba(255, 152, 0, 0.1)', false));
                    }
                });
            }

            // 4. INTERFERENCE AREAS (Red)
            if (showInterference) {
                Object.entries(deviceZones.mmwave_interference_areas).forEach(([areaId, config]) => {
                    const targetKey = `mmwave_interference_areas:${areaId}`;
                    if (isEditingZone && editingTarget === targetKey) {
                        if (draftZoneConfig) activeDraftShape = createShapeObj(draftZoneConfig, 'rgba(255, 82, 82, 0.9)', 'rgba(255, 82, 82, 0.3)', true);
                    } else if (config && !isEditingZone) {
                        shapes.push(createShapeObj(config, `rgba(255, 82, 82, 0.6)`, 'rgba(255, 82, 82, 0.2)', false));
                    }
                });
            }

            // CRITICAL FIX: Push the active editable shape LAST so it is drawn ON TOP
            if (activeDraftShape) {
                shapes.push(activeDraftShape);
            }

            return shapes;
        }

        // --- NEW: Generate Labels for Radar Shapes ---
        function getChartAnnotations() {
            // Label Toggle Check
            if (!showLabels) return [];
            // Don't show labels while editing
            if (isEditingZone) return []; 

            let annotations = [];

            // Helper to add label
            const addLabel = (config, text, color) => {
                if (config) {
                    let labelText = text;
                    if (showZValues) {
                        labelText += `<br>Z: ${config.z_min}-${config.z_max}`;
                    }

                    annotations.push({
                        x: (config.x_min + config.x_max) / 2,
                        y: (config.y_min + config.y_max) / 2,
                        xref: 'x', yref: 'y',
                        text: labelText,
                        showarrow: false,
                        font: { color: '#d8f9fc', size: 10, family: 'DM Sans, sans-serif' },
                        bgcolor: color,
                        borderpad: 2,
                        opacity: 0.88
                    });
                }
            };

            if (showDetection) {
                Object.entries(deviceZones.mmwave_detection_areas).forEach(([areaId, config]) => {
                    // Check individual sub-toggles
                    let isVisible = true;
                    if (areaId === 'area1' && !showDetection1) isVisible = false;
                    if (areaId === 'area2' && !showDetection2) isVisible = false;
                    if (areaId === 'area3' && !showDetection3) isVisible = false;
                    if (areaId === 'area4' && !showDetection4) isVisible = false;

                    if (isVisible) {
                        const isArea1 = areaId === 'area1';
                        const num = areaId.replace('area', '');
                        const label = isArea1 ? "D1 (Primary)" : `D${num}`;
                        // Use Blue for Area 1 label background
                        const color = isArea1 ? 'rgba(0, 188, 212, 0.8)' : 'rgba(76, 175, 80, 0.8)';
                        addLabel(config, label, color);
                    }
                });
            }

            if (showStay) {
                Object.entries(deviceZones.mmwave_stay_areas).forEach(([areaId, config]) => {
                    const num = areaId.replace('area', '');
                    addLabel(config, `S${num}`, 'rgba(255, 152, 0, 0.8)');
                });
            }

            if (showInterference) {
                Object.entries(deviceZones.mmwave_interference_areas).forEach(([areaId, config]) => {
                    const num = areaId.replace('area', '');
                    addLabel(config, `I${num}`, 'rgba(255, 82, 82, 0.8)');
                });
            }

            return annotations;
        }

        function createShapeObj(config, lineColor, fillColor, isEditable) {
            return {
                type: 'rect', 
                x0: config.x_min, x1: config.x_max, 
                y0: config.y_min, y1: config.y_max,
                line: { color: lineColor, width: 2, dash: isEditable ? 'dot' : 'solid' },
                fillcolor: fillColor,
                editable: isEditable
            };
        }

        function sendCommand(actionId) {
            socket.emit('send_command', actionId);

            if (zoneModule && typeof zoneModule.setPendingCommand === 'function') {
                zoneModule.setPendingCommand(actionId);
                return;
            }

            // Fallback expectation
            if (actionId === 1 || actionId === 3) {
                lastCommandId = actionId;
                if (window.SwitchStudioState) {
                    window.SwitchStudioState.setPacketStatus('syncing', actionId === 1 ? "Scanning for interference..." : "Clearing interference zones...");
                } else {
                    packetInfo.innerText = actionId === 1 ? "Scanning for interference..." : "Clearing interference zones...";
                }
            }
        }

        function handleForceSyncClick() {
            if (isEditingZone) {
                cancelZoneEdit();
            }
            socket.emit('request_devices');
            socket.emit('force_sync');
            if (window.SwitchStudioState) {
                window.SwitchStudioState.setPacketStatus('syncing', 'Syncing...');
            } else {
                packetInfo.innerText = 'Syncing...';
            }
        }

        configSidebar.addEventListener('change', function(event) {
            const input = event.target;
            if (!input || !(input.matches('input') || input.matches('select'))) return;
            if (!input.id) return;

            // Skip non-device config controls
            if (input.id.startsWith('viz') || input.id.startsWith('zoneEditor') || input.id.startsWith('edit')) return;

            const param = input.getAttribute('data-param');
            if (!param) return;

            let value = getInputValueForEmit(input);
            const fieldMeta = schemaFieldMap[param];
            if (fieldMeta && fieldMeta.type === 'binary' && typeof value === 'string') {
                if (value === 'true') value = true;
                else if (value === 'false') value = false;
            }

            if (window.SwitchStudioState && typeof window.SwitchStudioState.queueChange === 'function') {
                window.SwitchStudioState.queueChange(param, value, input);
                window.SwitchStudioState.setPacketStatus('info', 'Pending changes');
                return;
            }

            socket.emit('update_parameter', { param: param, value: value, request_id: `ui-${Date.now()}-${param}` });
        });

        // --- SOCKET EVENT HANDLERS ---
        socket.on('connect', () => {
            setConnectionState(true);
            socket.emit('request_devices');
            socket.emit('request_schema');
            syncTargetReportingAutoOffPreference();
        });
        socket.on('disconnect', () => {
            setConnectionState(false);
        });
        socket.on('connect_error', () => {
            setConnectionState(false);
        });

        socket.on('schema_model', function(schema) {
            schemaModel = schema || null;
            renderAllSchemaFields();
        });

        socket.on('command_result', function(result) {
            if (!result || !result.status) return;
            if (zoneModule && typeof zoneModule.handleCommandResult === 'function') {
                zoneModule.handleCommandResult(result);
            }

            if (result.action === 'set_target_reporting') {
                const payload = result.payload || {};
                if (result.status === 'error') {
                    // Revert the toggle on errors so the UI reflects actual device state.
                    if (targetReportToggle) targetReportToggle.checked = !targetReportToggle.checked;
                    if (window.SwitchStudioState) {
                        window.SwitchStudioState.setPacketStatus('error', result.message ? `Error: ${result.message}` : 'Target reporting update failed');
                    } else {
                        packetInfo.innerText = result.message ? `Error: ${result.message}` : 'Target reporting update failed';
                    }
                } else if (result.status === 'sent') {
                    const enabled = !!payload.enabled;
                    setTargetReportingState(enabled, payload.value);
                    if (window.SwitchStudioState) {
                        window.SwitchStudioState.showToast('saved', enabled ? 'Target reporting enabled' : 'Target reporting disabled', 1500);
                    }
                }
            }

            if (window.SwitchStudioState && typeof window.SwitchStudioState.handleCommandResult === 'function') {
                window.SwitchStudioState.handleCommandResult(result);
            } else {
                if (result.status === 'error') {
                    packetInfo.innerText = result.message ? `Error: ${result.message}` : "Command failed";
                    return;
                }
                if (result.action === 'update_parameter' && result.status === 'sent') {
                    packetInfo.innerText = "Setting updated";
                }
            }
        });
        
        socket.on('device_list', function(devices) {
            const currentSelection = deviceSelect.value;
            deviceSelect.innerHTML = '<option value="" disabled selected>Select a Device</option>';
            devices.forEach(device => {
                const option = document.createElement('option');
                option.value = device.topic; option.text = device.friendly_name;
                deviceSelect.appendChild(option);
            });
            if (currentSelection) deviceSelect.value = currentSelection;
            updateDeviceSelectState();
            // else deviceSelect.selectedIndex = 0; // Don't auto-select to prevent confusion
        });

        deviceSelect.addEventListener('change', function() {
            updateDeviceSelectState();
            socket.emit('change_device', this.value);
            
            // FIRE A FORCE SYNC TO PREVENT STALE DATA ON LOAD
            socket.emit('force_sync'); 

            statusDiv.innerText = `Monitoring: ${this.options[this.selectedIndex].text}`;
            if (window.SwitchStudioState) {
                window.SwitchStudioState.resetForDeviceChange();
                window.SwitchStudioState.setPacketStatus('info', 'Awaiting data...');
            } else {
                packetInfo.innerText = "Awaiting data...";
            }
            timestampSpan.innerText = "--:--:--";
            packetAgeSpan.innerText = "";
            lastPacketTime = null;
            
            occupancyVal.innerText = "Waiting..."; occupancyVal.className = "sensor-val badge-clear";
            illuminanceVal.innerText = "-- lx";
            if (stripIlluminanceVal) stripIlluminanceVal.innerText = "-- lx";
            occupancyState = { global: null, area1: null, area2: null, area3: null, area4: null };
            setTargetReportingState(false, 'Disable');
            
            // Reset Zone Indicators
            for(let i=1; i<=4; i++) {
                setAreaStatusIndicators(i, false);
            }
            setMapStandbyState(false);

            // Reset Visualization
            if (zoneModule && typeof zoneModule.resetHistory === 'function') {
                zoneModule.resetHistory();
            } else {
                targetHistory = {};
            }
            // Reset Zone Data
            deviceZones = {
                global: null,
                mmwave_detection_areas: { area1: null, area2: null, area3: null, area4: null },
                mmwave_interference_areas: { area1: null, area2: null, area3: null, area4: null },
                mmwave_stay_areas: { area1: null, area2: null, area3: null, area4: null }
            };
            
            // Cancel any active edits
            if (isEditingZone) cancelZoneEdit();

            Plotly.update('chart', {x: [[]], y: [[]], text: [[]]}, {shapes: getChartShapes(), annotations: []}); // Clear annotations on switch
            dataTableBody.innerHTML = '<tr><td colspan="5" class="no-data">No targets detected</td></tr>';
            nonMmwaveWarning.style.display = 'none'; 
        });

        // Helper: Convert Z2M area object to internal format and handle zeroed-out zones
        function parseZ2MArea(area) {
            if (!area) return null;
            
            let x0, x1, y0, y1, z0, z1;
            
            // Handle Z2M format (width_min) vs Raw Packet format (x_min)
            if ('width_min' in area) {
                x0 = area.width_min; x1 = area.width_max;
                y0 = area.depth_min; y1 = area.depth_max;
            } else if ('x_min' in area) {
                x0 = area.x_min; x1 = area.x_max;
                y0 = area.y_min; y1 = area.y_max;
            } else {
                return null;
            }
            
            // Handle Z (Height) - Check various common keys
            if ('height_min' in area) {
                 z0 = area.height_min; z1 = area.height_max;
            } else if ('z_min' in area) {
                 z0 = area.z_min; z1 = area.z_max;
            } else {
                 z0 = -300; z1 = 300; // Updated Default height per Inovelli specs
            }

            // Treat strictly zeroed zones as disabled/null (ignore Z for this check as partials might lack it)
            if (x0 === 0 && x1 === 0 && y0 === 0 && y1 === 0) return null;
            
            return { x_min: x0, x_max: x1, y_min: y0, y_max: y1, z_min: z0, z_max: z1 };
        }

        // --- FULL DEVICE CONFIGURATION & SENSORS ---
        socket.on('device_config', function(msg) {
            // Unpack wrapper
            if (!msg.topic || !msg.payload) return;
            const config = msg.payload;
            
            // FILTER: IGNORE DATA FROM OTHER DEVICES
            if (msg.topic !== deviceSelect.value) return;

            updateTimestamp(); 

            // 1. PARSE ZONES FOR VISUALIZATION
            if ("mmWaveWidthMin" in config) {
                 // Global Zone Config update
                 // Note: we might receive partial updates, so we need to merge
                 if (!deviceZones.mmwave_detection_areas.area1) deviceZones.mmwave_detection_areas.area1 = { x_min: -100, x_max: 100, y_min: 0, y_max: 600, z_min: -300, z_max: 300 }; // Default
                 if ("mmWaveWidthMin" in config) deviceZones.mmwave_detection_areas.area1.x_min = parseInt(config.mmWaveWidthMin);
                 if ("mmWaveWidthMax" in config) deviceZones.mmwave_detection_areas.area1.x_max = parseInt(config.mmWaveWidthMax);
                 if ("mmWaveDepthMin" in config) deviceZones.mmwave_detection_areas.area1.y_min = parseInt(config.mmWaveDepthMin);
                 if ("mmWaveDepthMax" in config) deviceZones.mmwave_detection_areas.area1.y_max = parseInt(config.mmWaveDepthMax);
            }

            if ("mmwave_detection_areas" in config) {
                const areas = config.mmwave_detection_areas || {}; 
                for (let i=1; i<=4; i++) deviceZones.mmwave_detection_areas[`area${i}`] = parseZ2MArea(areas[`area${i}`]);
            }
            if ("mmwave_interference_areas" in config) {
                 const areas = config.mmwave_interference_areas || {}; 
                for (let i=1; i<=4; i++) deviceZones.mmwave_interference_areas[`area${i}`] = parseZ2MArea(areas[`area${i}`]);
                
                // If we just cleared interference, finish status
                const pendingCommandId = zoneModule && typeof zoneModule.getPendingCommandId === 'function'
                    ? zoneModule.getPendingCommandId()
                    : lastCommandId;
                if (pendingCommandId === 3 && (!config.mmwave_interference_areas || Object.keys(config.mmwave_interference_areas).length === 0)) {
                    if (window.SwitchStudioState) {
                        window.SwitchStudioState.setPacketStatus('saved', 'Interference cleared');
                    } else {
                        packetInfo.innerText = "Interference Cleared";
                    }
                    if (zoneModule && typeof zoneModule.clearPendingCommand === 'function') {
                        zoneModule.clearPendingCommand();
                    } else {
                        lastCommandId = null;
                    }
                }
            }
            if ("mmwave_stay_areas" in config) {
                 const areas = config.mmwave_stay_areas || {}; 
                for (let i=1; i<=4; i++) deviceZones.mmwave_stay_areas[`area${i}`] = parseZ2MArea(areas[`area${i}`]);
            }
            
            // Refresh chart to show new zones (unless editing)
            if (!isEditingZone) {
                Plotly.relayout('chart', {shapes: getChartShapes(), annotations: getChartAnnotations()});
            }

            // 2. UPDATE LIVE SENSORS
            if ("occupancy" in config) {
                const parsedGlobal = parseOccupancyValue(config.occupancy);
                if (parsedGlobal === true) {
                    occupancyVal.innerText = "DETECTED";
                    occupancyVal.className = "sensor-val badge-detected";
                    occupancyState.global = true;
                } else if (parsedGlobal === false) {
                    occupancyVal.innerText = "CLEAR";
                    occupancyVal.className = "sensor-val badge-clear";
                    occupancyState.global = false;
                }
            }
            if ("illuminance" in config) {
                illuminanceVal.innerText = `${config.illuminance} lx`;
                if (stripIlluminanceVal) stripIlluminanceVal.innerText = `${config.illuminance} lx`;
            }
            if ("mmWaveTargetInfoReport" in config) {
                const enabled = parseTargetReportingEnabled(config.mmWaveTargetInfoReport);
                setTargetReportingState(enabled, config.mmWaveTargetInfoReport);
            }

            // Update Zone Status (mmwave_areaX_occupancy)
            for(let i=1; i<=4; i++) {
                const snakeKey = `mmwave_area${i}_occupancy`;
                const camelKey = `area${i}Occupancy`;
                let rawVal = null;
                if (snakeKey in config) rawVal = config[snakeKey];
                else if (camelKey in config) rawVal = config[camelKey];

                if(rawVal !== null) {
                    const parsedArea = parseOccupancyValue(rawVal);
                    if(parsedArea === true) {
                        setAreaStatusIndicators(i, true);
                        occupancyState[`area${i}`] = true;
                    } else if (parsedArea === false) {
                        setAreaStatusIndicators(i, false);
                        occupancyState[`area${i}`] = false;
                    }
                }
            }

            if (!hasActiveOccupancy()) {
                clearTargetsForOccupancyGate();
            } else {
                setMapStandbyState(false);
            }

            // 3. CHECK DEVICE TYPE (Fixed: Allow partial updates)
            if ("mmWaveVersion" in config) {
                // If this packet HAS version, it's definitely mmWave. Clear warnings.
                nonMmwaveWarning.style.display = 'none';
                configSidebar.style.opacity = '1';
                configSidebar.style.pointerEvents = 'auto';
                btnForceSync.disabled = false;
            } else if (nonMmwaveWarning.style.display === 'block') {
                // If warning is already ON, leave it ON unless we get confirmation otherwise
            }
            // We removed the logic that forces Warning ON if version is missing, because partial updates (like occupancy) lack it.

            // 4. SYNC CONFIG INPUTS
            if (window.SwitchStudioState && typeof window.SwitchStudioState.syncConfig === 'function') {
                window.SwitchStudioState.syncConfig(config);
            } else {
                for (const [key, value] of Object.entries(config)) {
                    const element = document.getElementById(key);
                    if (element) {
                        if (element.tagName === 'SPAN') {
                            element.innerText = value;
                        } else if (element.dataset.ledColorSelect === '1') {
                            setLedColorSelectValue(element, value);
                        } else if (element.type === 'checkbox') {
                            element.checked = value === true || value === 'ON' || value === 'true';
                        } else {
                            element.value = value;
                        }
                        if (element.dataset.ledBrightnessSlider === '1') {
                            refreshLedSliderDisplay(element);
                        }
                    }
                }
            }
            syncCompositeSchemaInputs(config);
        });

        // --- PLOTLY INIT ---
        const layout = {
            paper_bgcolor: '#0c1019',
            plot_bgcolor: '#08131d',
            xaxis: {
                range: [chartXMin, chartXMax],
                title: 'X - Width (cm)',
                gridcolor: 'rgba(176, 214, 224, 0.045)',
                zerolinecolor: 'rgba(13, 212, 192, 0.26)',
                linecolor: 'rgba(128, 150, 176, 0.25)',
                tickfont: { color: '#6f839d', size: 9 },
                titlefont: { color: '#62758f', size: 9 },
                fixedrange: true
            },
            yaxis: {
                range: [chartYMin, chartYMax],
                title: 'Y - Depth (cm)',
                gridcolor: 'rgba(176, 214, 224, 0.045)',
                zerolinecolor: 'rgba(13, 212, 192, 0.26)',
                linecolor: 'rgba(128, 150, 176, 0.25)',
                tickfont: { color: '#6f839d', size: 9 },
                titlefont: { color: '#62758f', size: 9 },
                fixedrange: true
            },
            margin: { t: 4, b: 34, l: 40, r: 14 },
            font: { color: '#9eacbf', family: 'DM Sans, sans-serif', size: 11 },
            showlegend: false,
            shapes: getChartShapes(),
            annotations: getChartAnnotations()
        };

        const chartConfig = {
            modeBarButtonsToRemove: ['select2d', 'lasso2d'], 
            displaylogo: false,
            scrollZoom: false, // Disabled by default until unlocked
            edits: {
                shapePosition: false // CRITICAL FIX: Initializes editability correctly
            },
            responsive: true // Enable internal Plotly responsiveness
        };

        Plotly.newPlot('chart', [
            {
                x: [],
                y: [],
                mode: 'markers+text',
                text: [],
                textposition: 'top center',
                marker: {
                    size: 11,
                    color: '#1bd2dc',
                    line: { color: '#dcfaff', width: 1.2 }
                },
                textfont: { color: '#bde8ef', size: 10, family: 'DM Sans, sans-serif' },
                type: 'scatter'
            },
            {
                x: [],
                y: [],
                mode: 'lines',
                line: { color: '#2e93bc', width: 1.6 },
                opacity: 0.2,
                type: 'scatter'
            }
        ], layout, chartConfig);

        if (window.SwitchStudioZones && typeof window.SwitchStudioZones.init === 'function') {
            zoneModule = window.SwitchStudioZones.init({
                chartId: 'chart',
                dataTableBodyEl: dataTableBody,
                zoneStatusId: 'zoneStatus',
                commandLogEl: commandLog,
                stateApi: window.SwitchStudioState || null,
                updateTimestamp: updateTimestamp,
                getLayout: () => layout,
                getIsEditing: () => isEditingZone,
                getIsInteracting: () => isInteracting,
                historyLength: HISTORY_LENGTH,
                shouldRenderTargets: () => hasActiveOccupancy()
            });
        }
        
        // Initial Visualizer Settings Apply
        setTimeout(applyVizSettings, 100);

        socket.on('zone_config', function(msg) {
            // Unpack wrapper
            if (!msg.topic || !msg.payload) return;
            const config = msg.payload;
            
            // FILTER: IGNORE DATA FROM OTHER DEVICES
            if (msg.topic !== deviceSelect.value) return;
            
            // Map the global config to our internal object
            deviceZones.global = {
                x_min: config.x_min, x_max: config.x_max,
                y_min: config.y_min, y_max: config.y_max
            };
            
            if (!isEditingZone) Plotly.relayout('chart', {shapes: getChartShapes(), annotations: getChartAnnotations()});
        });

        // --- INTERFERENCE ZONE LOGIC (From Raw Packets) ---
        socket.on('interference_zones', function(msg) {
            // Unpack wrapper
            if (!msg.topic || !msg.payload) return;
            const zones = msg.payload;

            // FILTER: IGNORE DATA FROM OTHER DEVICES
            if (msg.topic !== deviceSelect.value) return;

            // Update our internal state from the raw packet data
            // Note: The backend sends an array. We try to map it to area1..4
            for (let i = 0; i < 4; i++) {
                const areaKey = `area${i + 1}`;
                if (zones[i]) {
                    // Raw packets Cmd 2 do not carry Z. Preserve existing Z if available.
                    const existingZMin = deviceZones.mmwave_interference_areas[areaKey]?.z_min || 0;
                    const existingZMax = deviceZones.mmwave_interference_areas[areaKey]?.z_max || 300;

                    const newArea = parseZ2MArea(zones[i]);
                    if (newArea) {
                        newArea.z_min = existingZMin;
                        newArea.z_max = existingZMax;
                        deviceZones.mmwave_interference_areas[areaKey] = newArea;
                    }
                } else {
                    deviceZones.mmwave_interference_areas[areaKey] = null;
                }
            }

            if (!isEditingZone) Plotly.relayout('chart', {shapes: getChartShapes(), annotations: getChartAnnotations()});

            if (zoneModule && typeof zoneModule.handleInterferenceZones === 'function') {
                zoneModule.handleInterferenceZones(zones);
            } else if (lastCommandId !== null) {
                const statusBox = document.getElementById('zoneStatus');
                statusBox.style.display = 'block';
                if (zones.length === 0) {
                    statusBox.style.background = 'rgba(76, 175, 80, 0.9)';
                    statusBox.innerText = 'Scan complete: no active interference found.';
                } else {
                    statusBox.style.background = 'rgba(255, 82, 82, 0.9)';
                    statusBox.innerText = `Auto-config complete: found ${zones.length} zone(s).`;
                }
                setTimeout(() => { statusBox.style.display = 'none'; }, 5000);
                lastCommandId = null;
            }
        });

        socket.on('detection_zones', function(msg) {
            if (!msg.topic || !msg.payload) return;
            const zones = msg.payload;
            if (msg.topic !== deviceSelect.value) return;

            for(let i=0; i<4; i++) {
                if (zones[i]) {
                    const newArea = parseZ2MArea(zones[i]);
                    if (newArea) {
                         // Use Z from packet if available, else default from parseZ2MArea
                         if (zones[i].z_min !== undefined) newArea.z_min = zones[i].z_min;
                         if (zones[i].z_max !== undefined) newArea.z_max = zones[i].z_max;
                         deviceZones.mmwave_detection_areas[`area${i+1}`] = newArea;
                    }
                } else {
                    deviceZones.mmwave_detection_areas[`area${i+1}`] = null;
                }
            }
            if (!isEditingZone) Plotly.relayout('chart', {shapes: getChartShapes(), annotations: getChartAnnotations()});
        });

        socket.on('stay_zones', function(msg) {
            if (!msg.topic || !msg.payload) return;
            const zones = msg.payload;
            if (msg.topic !== deviceSelect.value) return;

            for(let i=0; i<4; i++) {
                if (zones[i]) {
                    const newArea = parseZ2MArea(zones[i]);
                    if (newArea) {
                         if (zones[i].z_min !== undefined) newArea.z_min = zones[i].z_min;
                         if (zones[i].z_max !== undefined) newArea.z_max = zones[i].z_max;
                         deviceZones.mmwave_stay_areas[`area${i+1}`] = newArea;
                    }
                } else {
                    deviceZones.mmwave_stay_areas[`area${i+1}`] = null;
                }
            }
            if (!isEditingZone) Plotly.relayout('chart', {shapes: getChartShapes(), annotations: getChartAnnotations()});
        });

        socket.on('new_data', function(msg) {
            if (zoneModule && typeof zoneModule.handleNewData === 'function') {
                if (zoneModule.handleNewData(msg, deviceSelect.value)) return;
            }

            // Unpack wrapper
            if (!msg.topic || !msg.payload) return;
            const data = msg.payload;
            
            // FILTER: IGNORE DATA FROM OTHER DEVICES
            if (msg.topic !== deviceSelect.value) return;

            if (!hasActiveOccupancy()) {
                clearTargetsForOccupancyGate();
                return;
            }
            setMapStandbyState(false);

            updateTimestamp();
            packetInfo.innerText = `Targets Visible: ${data.targets.length}`;
            packetInfo.style.color = '#00bcd4';
            
            const currentIds = new Set(data.targets.map(t => t.id));
            Object.keys(targetHistory).forEach(id => { if (!currentIds.has(Number(id))) delete targetHistory[id]; });

            data.targets.forEach(t => {
                if (!targetHistory[t.id]) targetHistory[t.id] = [];
                targetHistory[t.id].push({x: t.x, y: t.y});
                if (targetHistory[t.id].length > HISTORY_LENGTH) targetHistory[t.id].shift();
            });

            let historyX = [], historyY = [];
            Object.values(targetHistory).forEach(points => {
                points.forEach(p => { historyX.push(p.x); historyY.push(p.y); });
                historyX.push(null); historyY.push(null); 
            });

            const sizes = data.targets.map(t => Math.max(8, Math.min(40, 10 + (t.z / 5))));

            // CRITICAL JITTER FIX: If editing, use Plotly.restyle to ONLY update the points.
            // Do NOT touch the layout (shapes) or trigger a full redraw (Plotly.react).
            if (isEditingZone) {
                // IMPORTANT: If user is interacting (dragging), we SKIP updates entirely to prevent glitching
                if (isInteracting) return; 

                Plotly.restyle('chart', {
                    x: [data.targets.map(t => t.x), historyX],
                    y: [data.targets.map(t => t.y), historyY],
                    text: [data.targets.map(t => `ID: ${t.id} [Z:${t.z}cm]`), null],
                    'marker.size': [sizes, null]
                }, [0, 1]); // Update Trace 0 and 1
            } else {
                // Normal update
                Plotly.react('chart', [
                    {
                        x: data.targets.map(t => t.x),
                        y: data.targets.map(t => t.y),
                        text: data.targets.map(t => `ID: ${t.id} [Z:${t.z}cm]`),
                        mode: 'markers+text',
                        textposition: 'top center',
                        marker: { size: sizes, color: '#58d7f0', line: {color: '#e3f8fd', width: 1.6} },
                        textfont: { color: '#d7f5fb' },
                        type: 'scatter'
                    },
                    { x: historyX, y: historyY, mode: 'lines', line: {color: '#43cde8', width: 2}, opacity: 0.26, type: 'scatter' }
                ], layout);
            }

            if (data.targets.length === 0) {
                dataTableBody.innerHTML = '<tr><td colspan="5" class="no-data">Scanning for motion...</td></tr>';
                return;
            }

            dataTableBody.innerHTML = '';
            data.targets.forEach(t => {
                let dopStatus = "Stationary";
                let dopClass = "doppler-stationary";
                if (t.dop > 10) {
                    dopStatus = `Moving Away (${t.dop})`;
                    dopClass = "doppler-moving";
                } else if (t.dop < -10) {
                    dopStatus = `Approaching (${t.dop})`;
                    dopClass = "doppler-approaching";
                }

                dataTableBody.innerHTML += `<tr><td class="target-id-cell"><span class="target-id-tag">${t.id}</span></td><td class="target-num">${t.x} cm</td><td class="target-num">${t.y} cm</td><td class="target-num">${t.z} cm</td><td class="doppler-cell"><span class="doppler-badge ${dopClass}">${dopStatus}</span></td></tr>`;
            });
        });

        // --- INTERACTIVE ZONE EDITING ---

        // Start Edit Mode
        function startZoneEdit() {
            const target = zoneEditorSelect.value;
            if (!target) return;

            editingTarget = target;
            isEditingZone = true;
            btnStartEdit.style.display = 'none'; // Hide Start Button
            
            // Find existing config or create default
            let config = null;
            if (target === 'global') {
                config = deviceZones.global;
            } else {
                const [category, area] = target.split(':');
                config = deviceZones[category][area];
            }

            // If no existing config, create a default centered box with updated Z defaults
            if (!config) {
                config = { x_min: -100, x_max: 100, y_min: 50, y_max: 250, z_min: -300, z_max: 300 };
            }
            // Ensure Z exists (if config came from somewhere without it)
            if (config.z_min === undefined) config.z_min = -300;
            if (config.z_max === undefined) config.z_max = 300;

            // Set draft config and enable edit UI
            // Important: DEEP COPY to prevent reference leakage
            draftZoneConfig = JSON.parse(JSON.stringify(config));
            if (zoneModule && typeof zoneModule.normalizeZoneConfig === 'function') {
                draftZoneConfig = zoneModule.normalizeZoneConfig(draftZoneConfig, { allowZeroSpan: true, clampToBounds: true });
            }
            
            zoneEditorRawData.style.display = 'block';
            updateDraftCoordsText();

            // Enable drag in Plotly
            chartConfig.edits.shapePosition = true;
            layout.shapes = getChartShapes();
            layout.annotations = getChartAnnotations(); // Refresh annotations
            Plotly.react('chart', document.getElementById('chart').data, layout, chartConfig);
        }

        // Capture Plotly Drag Events
        document.getElementById('chart').on('plotly_relayout', function(eventData) {
            if (!isEditingZone) return;

            // Check if the event is a shape modification
            if (Object.keys(eventData).some(k => k.includes('shapes['))) {
                
                // Find the shape that is actively being edited (has dotted line)
                const shapes = document.getElementById('chart').layout.shapes;
                const activeShape = shapes.find(s => s.editable === true);

                if (activeShape) {
                    // Update only X/Y from drag, preserve Z
                    const rawDraft = {
                        x_min: Math.round(activeShape.x0),
                        x_max: Math.round(activeShape.x1),
                        y_min: Math.round(activeShape.y0),
                        y_max: Math.round(activeShape.y1),
                        z_min: draftZoneConfig.z_min,
                        z_max: draftZoneConfig.z_max
                    };
                    if (zoneModule && typeof zoneModule.normalizeZoneConfig === 'function') {
                        draftZoneConfig = zoneModule.normalizeZoneConfig(rawDraft, { allowZeroSpan: true, clampToBounds: true });
                    } else {
                        draftZoneConfig = rawDraft;
                    }
                    
                    updateDraftCoordsText();
                }
            }
        });
        
        // Manual Input Update
        function manualZoneUpdate() {
            if (!isEditingZone) return;

            const rawDraft = {
                x_min: parseInt(editXMin.value) || 0,
                x_max: parseInt(editXMax.value) || 0,
                y_min: parseInt(editYMin.value) || 0,
                y_max: parseInt(editYMax.value) || 0,
                z_min: parseInt(editZMin.value) || 0,
                z_max: parseInt(editZMax.value) || 0
            };
            if (zoneModule && typeof zoneModule.normalizeZoneConfig === 'function') {
                draftZoneConfig = zoneModule.normalizeZoneConfig(rawDraft, { allowZeroSpan: true, clampToBounds: true });
            } else {
                draftZoneConfig = rawDraft;
            }
             
            // Update the UI text (and potentially overlay text)
            updateDraftCoordsText();

            // Force Plotly update with new shapes based on manual input
            layout.shapes = getChartShapes();
            Plotly.react('chart', document.getElementById('chart').data, layout, chartConfig);
        }
        
        function updateDraftCoordsText() {
            if (draftZoneConfig) {
                // Only update inputs now, removed the popup text
                editXMin.value = draftZoneConfig.x_min;
                editXMax.value = draftZoneConfig.x_max;
                editYMin.value = draftZoneConfig.y_min;
                editYMax.value = draftZoneConfig.y_max;
                editZMin.value = draftZoneConfig.z_min;
                editZMax.value = draftZoneConfig.z_max;
            }
        }

        // Apply Button
        function applyZoneEdit() {
            if (!draftZoneConfig) return;

            const [category, area] = editingTarget.split(':');
            let areaPayload = null;

            if (zoneModule && typeof zoneModule.validateZoneConfig === 'function') {
                const validation = zoneModule.validateZoneConfig(draftZoneConfig, { allowZeroSpan: false });
                if (!validation.valid) {
                    const message = validation.errors && validation.errors.length > 0
                        ? validation.errors[0]
                        : 'Invalid zone coordinates';
                    if (window.SwitchStudioState) {
                        window.SwitchStudioState.setPacketStatus('error', message);
                        window.SwitchStudioState.showToast('error', message, 2800);
                    } else {
                        packetInfo.innerText = `Error: ${message}`;
                    }
                    return;
                }

                draftZoneConfig = validation.normalized;
                areaPayload = (typeof zoneModule.buildAreaPayload === 'function')
                    ? zoneModule.buildAreaPayload(area, draftZoneConfig)
                    : null;
            }

            if (!areaPayload) {
                const x_vals = [parseInt(draftZoneConfig.x_min), parseInt(draftZoneConfig.x_max)].sort((a,b)=>a-b);
                const y_vals = [parseInt(draftZoneConfig.y_min), parseInt(draftZoneConfig.y_max)].sort((a,b)=>a-b);
                const z_vals = [parseInt(draftZoneConfig.z_min), parseInt(draftZoneConfig.z_max)].sort((a,b)=>a-b);
                areaPayload = {};
                areaPayload[area] = {
                    width_min: x_vals[0],
                    width_max: x_vals[1],
                    depth_min: y_vals[0],
                    depth_max: y_vals[1],
                    height_min: z_vals[0],
                    height_max: z_vals[1]
                };
            }
             
            socket.emit('update_parameter', { param: category, value: areaPayload });

            endZoneEdit();
            if (window.SwitchStudioState) {
                window.SwitchStudioState.setPacketStatus('saved', 'Zone saved');
                window.SwitchStudioState.showToast('saved', 'Zone saved.', 1500);
            } else {
                packetInfo.innerText = "Zone Saved!";
            }
        }
        
        function deleteZone() {
            if (!confirm("Are you sure you want to delete this zone?")) return;
            
            const [category, area] = zoneEditorSelect.value.split(':');
            const areaPayload = {};
             
            // Always use width/depth keys for deletion
            areaPayload[area] = { 
                width_min: 0, width_max: 0, 
                depth_min: 0, depth_max: 0, 
                height_min: 0, height_max: 0 
            };
             
            socket.emit('update_parameter', { param: category, value: areaPayload });
            if (zoneModule && typeof zoneModule.appendCommandLog === 'function') {
                zoneModule.appendCommandLog(`Deleted zone ${area}`, 'info');
            }
            if (window.SwitchStudioState) {
                window.SwitchStudioState.setPacketStatus('saved', 'Zone deleted');
                window.SwitchStudioState.showToast('saved', 'Zone deleted.', 1500);
            } else {
                packetInfo.innerText = "Zone Deleted.";
            }
            endZoneEdit(); // Close editor
        }

        // Cancel Button - Restores view
        function cancelZoneEdit() {
            endZoneEdit();
            socket.emit('force_sync'); // Refresh from device to undo visual changes
        }
        
        function endZoneEdit() {
            isEditingZone = false;
            editingTarget = null;
            draftZoneConfig = null;
            //zoneEditorControls.style.display = 'none'; // REMOVED
            zoneEditorRawData.style.display = 'none';
            btnStartEdit.style.display = 'block'; // Show Start Button again

            // Reset chart editability
            chartConfig.edits.shapePosition = false;
            
            layout.shapes = getChartShapes();
            layout.annotations = getChartAnnotations(); // Reset annotations
            Plotly.react('chart', document.getElementById('chart').data, layout, chartConfig);
        }
    </script>
</body>
</html>



